<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
  <title>SyncLite Many-to-Many Screen Share V25</title>
  <script src="https://cdn.tailwindcss.com"></script>
  <script src="https://unpkg.com/react@18/umd/react.development.js"></script>
  <script src="https://unpkg.com/react-dom@18/umd/react-dom.development.js"></script>
  <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>
  <script src="https://webrtc.github.io/adapter/adapter-latest.js"></script>
  <script src="https://unpkg.com/peerjs@1.5.2/dist/peerjs.min.js"></script>
</head>
<body>
  <div id="root" class="min-h-screen bg-gray-100 flex flex-col items-center p-4"></div>

  <script type="text/babel">
    const { useState, useEffect, useRef } = React;

    function App() {
      const [peerId, setPeerId] = useState('');
      const [peer, setPeer] = useState(null);
      const [allPeers, setAllPeers] = useState([]); // List of all peer IDs (including self)
      const [knownPeers, setKnownPeers] = useState(''); // Comma-separated peer IDs to connect to
      const [connections, setConnections] = useState({}); // { peerId: DataConnection }
      const [calls, setCalls] = useState({}); // { peerId: MediaConnection }
      const [localStream, setLocalStream] = useState(null);
      const [remoteStreams, setRemoteStreams] = useState({}); // { peerId: MediaStream }
      const [isAudioMuted, setIsAudioMuted] = useState(false);
      const [isScreenSharing, setIsScreenSharing] = useState(false);
      const localVideoRef = useRef(null);

      // 1. Initialize PeerJS
      useEffect(() => {
        const p = new Peer();
        setPeer(p);
        p.on('open', id => {
          setPeerId(id);
        });

        // 2. Handle incoming data connections (peer list exchange)
        p.on('connection', conn => {
          conn.on('data', data => {
            if (data.type === 'peer-list') {
              const newPeers = data.peers.filter(pid => pid !== peerId);
              setAllPeers(prev => Array.from(new Set([...prev, ...newPeers, peerId])));
            }
          });
        });

        // 3. Handle incoming media calls
        p.on('call', call => {
          call.answer(localStream);
          call.on('stream', remoteStream => {
            setRemoteStreams(prev => ({ ...prev, [call.peer]: remoteStream }));
          });
          setCalls(prev => ({ ...prev, [call.peer]: call }));
        });

        return () => {
          p.destroy();
          if (localStream) localStream.getTracks().forEach(t => t.stop());
        };
      }, []);

      // 4. Get local media (mic, optionally screen)
      const getLocalMedia = async (withScreen = false) => {
        try {
          let stream;
          if (withScreen) {
            const screenStream = await navigator.mediaDevices.getDisplayMedia({ video: true, audio: false });
            const micStream = await navigator.mediaDevices.getUserMedia({ audio: true });
            stream = new MediaStream([
              ...screenStream.getVideoTracks(),
              ...micStream.getAudioTracks()
            ]);
            screenStream.getVideoTracks()[0].addEventListener('ended', () => setIsScreenSharing(false));
            setIsScreenSharing(true);
          } else {
            stream = await navigator.mediaDevices.getUserMedia({ audio: true, video: false });
            setIsScreenSharing(false);
          }
          setLocalStream(stream);
          if (localVideoRef.current) {
            localVideoRef.current.srcObject = stream;
          }
        } catch (e) {
          alert('Could not get local media: ' + e.message);
        }
      };

      // 5. Connect to known peers (comma-separated list)
      const connectToPeers = () => {
        if (!peer) return;
        const peerIds = knownPeers.split(',').map(x => x.trim()).filter(x => x && x !== peerId);
        setAllPeers(Array.from(new Set([...peerIds, peerId])));
        peerIds.forEach(pid => {
          if (!connections[pid]) {
            const conn = peer.connect(pid);
            conn.on('open', () => {
              // Exchange peer lists for mesh topology
              conn.send({ type: 'peer-list', peers: [...peerIds, peerId] });
            });
            conn.on('data', data => {
              if (data.type === 'peer-list') {
                const newPeers = data.peers.filter(pid => pid !== peerId);
                setAllPeers(prev => Array.from(new Set([...prev, ...newPeers, peerId])));
              }
            });
            setConnections(prev => ({ ...prev, [pid]: conn }));
          }
        });
      };

      // 6. Call all peers (send local stream)
      useEffect(() => {
        if (!peer || !localStream) return;
        allPeers.forEach(pid => {
          if (pid === peerId) return;
          if (!calls[pid]) {
            const call = peer.call(pid, localStream);
            call.on('stream', remoteStream => {
              setRemoteStreams(prev => ({ ...prev, [pid]: remoteStream }));
            });
            setCalls(prev => ({ ...prev, [pid]: call }));
          }
        });
      }, [allPeers, localStream, peerId, peer]);

      // 7. Mute/unmute mic
      const toggleMute = () => {
        if (!localStream) return;
        localStream.getAudioTracks().forEach(track => {
          track.enabled = !isAudioMuted;
        });
        setIsAudioMuted(!isAudioMuted);
      };

      // 8. Start/stop screen sharing
      const toggleScreenShare = async () => {
        if (!isScreenSharing) {
          await getLocalMedia(true);
        } else {
          await getLocalMedia(false);
        }
      };

      // 9. Show local video when available
      useEffect(() => {
        if (localStream && localVideoRef.current) {
          localVideoRef.current.srcObject = localStream;
        }
      }, [localStream]);

      // 10. Show remote videos
      const remoteVideos = Object.entries(remoteStreams).map(([pid, stream]) => (
        <div key={pid} className="mb-2">
          <div className="text-xs text-gray-500 mb-1">Peer: {pid}</div>
          <video
            autoPlay
            playsInline
            controls
            className="w-full max-h-48 rounded shadow"
            ref={el => { if (el) el.srcObject = stream; }}
          />
        </div>
      ));

      return (
        <div className="max-w-lg w-full bg-white shadow-lg rounded p-6">
          <h1 className="text-2xl font-bold text-purple-600 mb-4 text-center">SyncLite V25 (Many-to-Many)</h1>

          <div className="bg-gray-100 p-3 rounded mb-4 text-sm">
            <div><strong>Your Peer ID:</strong> <span className="font-mono">{peerId}</span></div>
            <div><strong>Known Peers:</strong> {allPeers.filter(pid => pid !== peerId).join(', ') || 'None'}</div>
          </div>

          <div className="mb-4">
            <input
              className="border p-2 w-full rounded"
              placeholder="Comma-separated Peer IDs to connect"
              value={knownPeers}
              onChange={e => setKnownPeers(e.target.value)}
            />
            <button
              onClick={connectToPeers}
              className="bg-purple-600 hover:bg-purple-700 text-white py-2 px-4 rounded w-full font-semibold mt-2"
            >
              Connect to Peers
            </button>
          </div>

          <div className="mb-4 flex space-x-2">
            <button
              onClick={() => getLocalMedia(false)}
              className="bg-blue-600 hover:bg-blue-700 text-white py-2 px-4 rounded font-semibold flex-1"
            >
              Mic Only
            </button>
            <button
              onClick={toggleScreenShare}
              className={`${
                isScreenSharing
                  ? 'bg-red-600 hover:bg-red-700'
                  : 'bg-green-600 hover:bg-green-700'
              } text-white py-2 px-4 rounded font-semibold flex-1`}
            >
              {isScreenSharing ? 'Stop Screen Share' : 'Screen + Mic'}
            </button>
          </div>

          {localStream && (
            <div className="mb-4">
              <div className="text-xs text-gray-500 mb-1">You</div>
              <video
                ref={localVideoRef}
                autoPlay
                muted
                playsInline
                controls
                className="w-full max-h-48 rounded shadow"
              />
              <button
                onClick={toggleMute}
                className={`w-full mt-2 py-2 px-4 rounded font-semibold ${
                  isAudioMuted ? 'bg-red-600 hover:bg-red-700' : 'bg-green-600 hover:bg-green-700'
                } text-white`}
              >
                {isAudioMuted ? 'Unmute Mic' : 'Mute Mic'}
              </button>
            </div>
          )}

          {remoteVideos.length > 0 && (
            <div>
              <h2 className="text-lg font-bold mb-2">Remote Streams</h2>
              {remoteVideos}
            </div>
          )}
        </div>
      );
    }

    ReactDOM.createRoot(document.getElementById('root')).render(<App />);
  </script>
</body>
</html>
