<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>SyncLite V28 - Screen & Audio Sharing</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <script src="https://unpkg.com/peerjs@1.5.2/dist/peerjs.min.js"></script>
    <script src="https://unpkg.com/react@17/umd/react.development.js"></script>
    <script src="https://unpkg.com/react-dom@17/umd/react-dom.development.js"></script>
    <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>
  </head>
  <body class="bg-gray-100 min-h-screen flex items-center justify-center">
    <div id="root"></div>

    <script type="text/babel">
      const { useEffect, useRef, useState } = React;

      function App() {
        const [peerId, setPeerId] = useState("");
        const [remoteId, setRemoteId] = useState("");
        const [isHost, setIsHost] = useState(false);
        const [status, setStatus] = useState("Idle");
        const [remoteStream, setRemoteStream] = useState(null);

        const peerRef = useRef(null);
        const connRef = useRef(null);
        const streamRef = useRef(null);
        const callRef = useRef(null);
        const connectedPeers = useRef([]);
        const participantMicTrack = useRef(null);

        useEffect(() => {
          const peer = new Peer();
          peerRef.current = peer;

          peer.on("open", (id) => {
            setPeerId(id);
            setStatus("Peer created: " + id);
          });

          peer.on("connection", (conn) => {
            connRef.current = conn;
            connectedPeers.current.push(conn);

            // Send back all known peers to the new participant
            conn.on("open", () => {
              const peerList = connectedPeers.current.map((c) => c.peer);
              conn.send(peerList);

              if (streamRef.current) {
                const call = peer.call(conn.peer, streamRef.current);
                callRef.current = call;
              }
            });
          });

          peer.on("call", async (call) => {
            call.answer();
            call.on("stream", (incomingStream) => {
              const hasVideo = incomingStream.getVideoTracks().length > 0;

              if (hasVideo && !isHost) {
                setRemoteStream(incomingStream);
                setStatus("Receiving screen & audio...");
              } else {
                const audio = new Audio();
                audio.srcObject = incomingStream;
                audio.autoplay = true;
                audio.playsInline = true;
                setStatus("Receiving peer audio");
              }
            });
          });
        }, []);

        const startHost = async () => {
          setIsHost(true);
          setStatus("Getting screen and mic...");

          const screenStream = await navigator.mediaDevices.getDisplayMedia({ video: true });
          const micStream = await navigator.mediaDevices.getUserMedia({ audio: true });

          screenStream.addTrack(micStream.getAudioTracks()[0]);
          streamRef.current = screenStream;

          setStatus("Hosting screen & audio...");
        };

        const connectToHost = async () => {
          if (!peerRef.current || !remoteId) return;

          const micStream = await navigator.mediaDevices.getUserMedia({ audio: true });
          participantMicTrack.current = micStream.getAudioTracks()[0];

          const conn = peerRef.current.connect(remoteId);
          connRef.current = conn;
          connectedPeers.current.push(conn);

          conn.on("open", () => {
            setStatus("Connected to host");
            peerRef.current.call(remoteId, micStream);
          });

          conn.on("data", (peerList) => {
            peerList.forEach((peerId) => {
              if (peerId !== peerRef.current.id && peerId !== remoteId) {
                const connToPeer = peerRef.current.connect(peerId);
                connectedPeers.current.push(connToPeer);
                connToPeer.on("open", () => {
                  peerRef.current.call(peerId, micStream);
                });
              }
            });
          });
        };

        return (
          <div className="p-6 bg-white rounded-xl shadow-md w-full max-w-xl">
            <h1 className="text-2xl font-bold mb-4">SyncLite V28</h1>
            <p className="mb-2">Your ID: <strong>{peerId}</strong></p>
            <input
              className="border p-2 rounded w-full mb-4"
              placeholder="Enter Host ID"
              value={remoteId}
              onChange={(e) => setRemoteId(e.target.value)}
            />
            <div className="flex gap-2 mb-4">
              <button
                onClick={startHost}
                className="bg-blue-500 text-white px-4 py-2 rounded hover:bg-blue-600"
              >
                Start Hosting
              </button>
              <button
                onClick={connectToHost}
                className="bg-green-500 text-white px-4 py-2 rounded hover:bg-green-600"
              >
                Join as Participant
              </button>
            </div>
            <p className="mb-4 text-gray-700">Status: {status}</p>

            {remoteStream && (
              <video
                className="w-full rounded-lg border"
                srcObject={remoteStream}
                autoPlay
                playsInline
              />
            )}
          </div>
        );
      }

      ReactDOM.render(<App />, document.getElementById("root"));
    </script>
  </body>
</html>
