<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>SyncLite Audio Chat</title>
  <script src="https://cdn.tailwindcss.com"></script>
  <script src="https://unpkg.com/react@18/umd/react.development.js"></script>
  <script src="https://unpkg.com/react-dom@18/umd/react-dom.development.js"></script>
  <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>
  <script src="https://webrtc.github.io/adapter/adapter-latest.js"></script>
</head>
<body>
  <div id="root" class="min-h-screen bg-gray-100 flex flex-col items-center p-4"></div>
  <script type="text/babel">
    const { useState, useEffect, useRef } = React;

    function App() {
      const [sessionId, setSessionId] = useState('123');
      const [stream, setStream] = useState(null);
      const [peerConnection, setPeerConnection] = useState(null);
      const [offer, setOffer] = useState('');
      const [answer, setAnswer] = useState('');
      const [remoteOffer, setRemoteOffer] = useState('');
      const [remoteAnswer, setRemoteAnswer] = useState('');
      const [iceCandidates, setIceCandidates] = useState([]);
      const [remoteIceCandidate, setRemoteIceCandidate] = useState('');
      const [status, setStatus] = useState('Disconnected');
      const audioRef = useRef(null);

      // Initialize WebRTC
      const initWebRTC = async (isScreenShare = false) => {
        try {
          const pc = new RTCPeerConnection({
            iceServers: [
              { urls: 'stun:stun.l.google.com:19302' },
              { urls: 'stun:stun1.l.google.com:19302' },
              { urls: 'stun:stun2.l.google.com:19302' },
              { urls: 'stun:stun3.l.google.com:19302' },
            ],
          });
          setPeerConnection(pc);
          setStatus('Connecting...');

          // Get media (audio or screen)
          const media = isScreenShare
            ? await navigator.mediaDevices.getDisplayMedia({ video: true })
            : await navigator.mediaDevices.getUserMedia({ audio: true });
          setStream(media);
          media.getTracks().forEach((track) => pc.addTrack(track, media));

          // Display remote stream
          pc.ontrack = (event) => {
            if (audioRef.current) {
              audioRef.current.srcObject = event.streams[0];
              setStatus('Connected');
            }
          };

          // Collect ICE candidates
          pc.onicecandidate = (event) => {
            if (event.candidate) {
              setIceCandidates((prev) => [...prev, JSON.stringify(event.candidate)]);
            }
          };

          // Create offer for initiator
          if (!remoteOffer) {
            const offer = await pc.createOffer();
            await pc.setLocalDescription(offer);
            setOffer(JSON.stringify(offer));
            setStatus('Offer created, copy and send to other user');
          }

          // Monitor ICE connection state
          pc.oniceconnectionstatechange = () => {
            setStatus(`ICE state: ${pc.iceConnectionState}`);
            if (pc.iceConnectionState === 'failed') {
              setStatus('Connection failed, try restarting or different network');
              pc.restartIce();
            }
            if (pc.iceConnectionState === 'connected') {
              setStatus('Connected');
            }
          };

          return pc;
        } catch (e) {
          setStatus(`Error: ${e.message}`);
          alert(`Error initializing WebRTC: ${e.message}`);
          return null;
        }
      };

      // Start audio chat
      const startAudioChat = async () => {
        const pc = await initWebRTC(false);
        if (pc) setPeerConnection(pc);
      };

      // Start screen sharing
      const startScreenShare = async () => {
        const pc = await initWebRTC(true);
        if (pc) setPeerConnection(pc);
      };

      // Handle remote offer
      const handleRemoteOffer = async () => {
        if (!peerConnection || !remoteOffer) {
          setStatus('Error: Start audio chat first or enter remote offer');
          alert('Error: Start audio chat first or enter remote offer');
          return;
        }
        try {
          await peerConnection.setRemoteDescription(
            new RTCSessionDescription(JSON.parse(remoteOffer))
          );
          const answer = await peerConnection.createAnswer();
          await peerConnection.setLocalDescription(answer);
          setAnswer(JSON.stringify(answer));
          setStatus('Answer created, copy and send to other user');
        } catch (e) {
          setStatus(`Error setting remote offer: ${e.message}`);
          alert(`Error setting remote offer: ${e.message}`);
        }
      };

      // Handle remote answer
      const handleRemoteAnswer = async () => {
        if (!peerConnection || !remoteAnswer) {
          setStatus('Error: Start audio chat first or enter remote answer');
          alert('Error: Start audio chat first or enter remote answer');
          return;
        }
        try {
          await peerConnection.setRemoteDescription(
            new RTCSessionDescription(JSON.parse(remoteAnswer))
          );
          setStatus('Answer set, waiting for connection');
        } catch (e) {
          setStatus(`Error setting remote answer: ${e.message}`);
          alert(`Error setting remote answer: ${e.message}`);
        }
      };

      // Handle remote ICE candidate
      const handleRemoteIceCandidate = async () => {
        if (!peerConnection || !remoteIceCandidate) {
          setStatus('Error: Start audio chat first or enter ICE candidate');
          alert('Error: Start audio chat first or enter ICE candidate');
          return;
        }
        try {
          await peerConnection.addIceCandidate(
            new RTCIceCandidate(JSON.parse(remoteIceCandidate))
          );
          setStatus('ICE candidate added, waiting for connection');
        } catch (e) {
          setStatus(`Error adding ICE candidate: ${e.message}`);
          alert(`Error adding ICE candidate: ${e.message}`);
        }
      };

      // Clean up WebRTC
      useEffect(() => {
        return () => {
          if (peerConnection) peerConnection.close();
          if (stream) stream.getTracks().forEach((track) => track.stop());
        };
      }, [peerConnection, stream]);

      return (
        <div className="w-full max-w-md">
          <h1 className="text-2xl font-bold mb-4 text-center">SyncLite Audio Chat V3</h1>
          <p className="text-sm mb-2 text-center">Status: {status}</p>
          <input
            type="text"
            value={sessionId}
            onChange={(e) => setSessionId(e.target.value)}
            placeholder="Session ID"
            className="border p-2 mb-2 w-full rounded"
          />
          <button
            onClick={startAudioChat}
            className="bg-green-500 text-white p-2 rounded w-full mb-2"
          >
            Start Audio Chat
          </button>
          <button
            onClick={startScreenShare}
            className="bg-purple-500 text-white p-2 rounded w-full mb-2"
          >
            Share Screen
          </button>
          <textarea
            value={offer}
            readOnly
            placeholder="Your offer (copy this)"
            className="border p-2 mb-2 w-full rounded h-24 bg-gray-200"
          />
          <textarea
            value={answer}
            readOnly
            placeholder="Your answer (copy this)"
            className="border p-2 mb-2 w-full rounded h-24 bg-gray-200"
          />
          <textarea
            value={iceCandidates.join('\n')}
            readOnly
            placeholder="Your ICE candidates (copy these)"
            className="border p-2 mb-2 w-full rounded h-24 bg-gray-200"
          />
          <textarea
            value={remoteOffer}
            onChange={(e) => setRemoteOffer(e.target.value)}
            placeholder="Paste remote offer here"
            className="border p-2 mb-2 w-full rounded h-24"
          />
          <button
            onClick={handleRemoteOffer}
            className="bg-blue-500 text-white p-2 rounded w-full mb-2"
          >
            Set Remote Offer
          </button>
          <textarea
            value={remoteAnswer}
            onChange={(e) => setRemoteAnswer(e.target.value)}
            placeholder="Paste remote answer here"
            className="border p-2 mb-2 w-full rounded h-24"
          />
          <button
            onClick={handleRemoteAnswer}
            className="bg-blue-500 text-white p-2 rounded w-full mb-2"
          >
            Set Remote Answer
          </button>
          <textarea
            value={remoteIceCandidate}
            onChange={(e) => setRemoteIceCandidate(e.target.value)}
            placeholder="Paste remote ICE candidate here"
            className="border p-2 mb-2 w-full rounded h-24"
          />
          <button
            onClick={handleRemoteIceCandidate}
            className="bg-blue-500 text-white p-2 rounded w-full mb-2"
          >
            Add ICE Candidate
          </button>
          <audio
            ref={audioRef}
            autoPlay
            className="w-full"
          />
        </div>
      );
    }

    ReactDOM.render(<App />, document.getElementById('root'));
  </script>
</body>
</html>