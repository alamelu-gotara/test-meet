<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
  <title>SyncLite Screen Share V24 - Many to Many</title>
  <script src="https://cdn.tailwindcss.com"></script>
  <script src="https://unpkg.com/react@18/umd/react.development.js"></script>
  <script src="https://unpkg.com/react-dom@18/umd/react-dom.development.js"></script>
  <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>
  <script src="https://webrtc.github.io/adapter/adapter-latest.js"></script>
  <script src="https://unpkg.com/peerjs@1.5.2/dist/peerjs.min.js"></script>
</head>
<body>
  <div id="root" class="min-h-screen bg-gray-100 flex flex-col items-center p-4"></div>

  <script type="text/babel">
    const { useState, useEffect, useRef } = React;

    function App() {
      const [roomId, setRoomId] = useState('');
      const [myPeerId, setMyPeerId] = useState('');
      const [displayName, setDisplayName] = useState('');
      const [status, setStatus] = useState('Initializing...');
      const [isInRoom, setIsInRoom] = useState(false);
      const [isScreenSharing, setIsScreenSharing] = useState(false);
      const [isAudioMuted, setIsAudioMuted] = useState(false);
      const [participants, setParticipants] = useState([]);
      
      const peer = useRef(null);
      const myStream = useRef(null);
      const connections = useRef({});
      const calls = useRef({});
      const streams = useRef({});
      const myMicTrack = useRef(null);

      // Initialize PeerJS
      useEffect(() => {
        const p = new Peer();
        
        p.on('open', id => {
          setMyPeerId(id);
          setStatus('Ready to join or create a room');
        });

        // Handle incoming connections
        p.on('connection', conn => {
          handleNewConnection(conn);
        });

        // Handle incoming calls
        p.on('call', call => {
          handleIncomingCall(call);
        });

        peer.current = p;

        return () => {
          // Clean up
          if (myStream.current) {
            myStream.current.getTracks().forEach(track => track.stop());
          }
          
          // Close all connections
          Object.values(connections.current).forEach(conn => conn.close());
          
          // Close all calls
          Object.values(calls.current).forEach(call => call.close());
          
          p.destroy();
        };
      }, []);

      const handleNewConnection = (conn) => {
        const peerId = conn.peer;
        
        connections.current[peerId] = conn;
        
        conn.on('open', () => {
          // Send my info to the new participant
          conn.send({
            type: 'USER_INFO',
            peerId: myPeerId,
            displayName: displayName,
            isScreenSharing: isScreenSharing
          });
          
          // Send list of other participants to the new participant
          conn.send({
            type: 'PARTICIPANTS_LIST',
            participants: participants
          });
          
          setStatus(`${peerId} connected`);
        });
        
        conn.on('data', data => {
          handleDataMessage(data, peerId);
        });
        
        conn.on('close', () => {
          removeParticipant(peerId);
        });
      };

      const handleIncomingCall = (call) => {
        const peerId = call.peer;
        
        // Answer the call with my audio stream if available, otherwise empty stream
        let answerStream = new MediaStream();
        if (myMicTrack.current) {
          answerStream.addTrack(myMicTrack.current);
        }
        
        call.answer(answerStream);
        
        calls.current[peerId] = call;
        
        call.on('stream', remoteStream => {
          streams.current[peerId] = remoteStream;
          
          // Update the participants list with the new stream
          setParticipants(prevParticipants => 
            prevParticipants.map(p => 
              p.peerId === peerId ? { ...p, hasStream: true } : p
            )
          );
        });
        
        call.on('close', () => {
          // Handle call closed
          if (streams.current[peerId]) {
            delete streams.current[peerId];
            
            setParticipants(prevParticipants => 
              prevParticipants.map(p => 
                p.peerId === peerId ? { ...p, hasStream: false } : p
              )
            );
          }
        });
      };

      const handleDataMessage = (data, fromPeerId) => {
        if (!data.type) return;
        
        switch (data.type) {
          case 'USER_INFO':
            // Add new participant to the list
            addParticipant({
              peerId: data.peerId,
              displayName: data.displayName,
              isScreenSharing: data.isScreenSharing,
              hasStream: false
            });
            break;
            
          case 'PARTICIPANTS_LIST':
            // Add all participants from the list
            data.participants.forEach(participant => {
              if (participant.peerId !== myPeerId) {
                addParticipant(participant);
                
                // Connect to this participant if not already connected
                if (!connections.current[participant.peerId]) {
                  connectToPeer(participant.peerId);
                }
              }
            });
            break;
            
          case 'SCREEN_SHARING_STARTED':
            // Update participant's screen sharing status
            setParticipants(prevParticipants => 
              prevParticipants.map(p => 
                p.peerId === fromPeerId ? { ...p, isScreenSharing: true } : p
              )
            );
            break;
            
          case 'SCREEN_SHARING_STOPPED':
            // Update participant's screen sharing status
            setParticipants(prevParticipants => 
              prevParticipants.map(p => 
                p.peerId === fromPeerId ? { ...p, isScreenSharing: false } : p
              )
            );
            break;
            
          default:
            break;
        }
      };

      const addParticipant = (participant) => {
        // Check if participant already exists
        setParticipants(prevParticipants => {
          const exists = prevParticipants.some(p => p.peerId === participant.peerId);
          if (!exists) {
            return [...prevParticipants, participant];
          }
          return prevParticipants;
        });
      };

      const removeParticipant = (peerId) => {
        // Remove participant from the list
        setParticipants(prevParticipants => 
          prevParticipants.filter(p => p.peerId !== peerId)
        );
        
        // Clean up resources
        if (connections.current[peerId]) {
          connections.current[peerId].close();
          delete connections.current[peerId];
        }
        
        if (calls.current[peerId]) {
          calls.current[peerId].close();
          delete calls.current[peerId];
        }
        
        if (streams.current[peerId]) {
          delete streams.current[peerId];
        }
      };

      const connectToPeer = (remotePeerId) => {
        if (!peer.current || !remotePeerId || remotePeerId === myPeerId) return;
        
        // Create a data connection
        const conn = peer.current.connect(remotePeerId);
        connections.current[remotePeerId] = conn;
        
        conn.on('open', () => {
          // Send my info to the remote peer
          conn.send({
            type: 'USER_INFO',
            peerId: myPeerId,
            displayName: displayName,
            isScreenSharing: isScreenSharing
          });
          
          // If I'm screen sharing, call the remote peer
          if (myStream.current) {
            callPeer(remotePeerId);
          }
        });
        
        conn.on('data', data => {
          handleDataMessage(data, remotePeerId);
        });
        
        conn.on('close', () => {
          removeParticipant(remotePeerId);
        });
      };

      const callPeer = (remotePeerId) => {
        if (!peer.current || !remotePeerId || !myStream.current) return;
        
        // Create a media call
        const call = peer.current.call(remotePeerId, myStream.current);
        calls.current[remotePeerId] = call;
        
        call.on('stream', remoteStream => {
          streams.current[remotePeerId] = remoteStream;
          
          // Update the participants list with the new stream
          setParticipants(prevParticipants => 
            prevParticipants.map(p => 
              p.peerId === remotePeerId ? { ...p, hasStream: true } : p
            )
          );
        });
        
        call.on('close', () => {
          // Handle call closed
          if (streams.current[remotePeerId]) {
            delete streams.current[remotePeerId];
            
            setParticipants(prevParticipants => 
              prevParticipants.map(p => 
                p.peerId === remotePeerId ? { ...p, hasStream: false } : p
              )
            );
          }
        });
      };

      const joinRoom = () => {
        if (!roomId || !displayName) return;
        
        // Set up audio for all connections
        navigator.mediaDevices.getUserMedia({ audio: true })
          .then(micStream => {
            const audioTrack = micStream.getAudioTracks()[0];
            myMicTrack.current = audioTrack;
            
            setIsInRoom(true);
            setStatus(`Joined room: ${roomId}`);
            
            // Connect to the room using roomId as the first peer
            connectToPeer(roomId);
          })
          .catch(err => {
            setStatus(`Microphone error: ${err.message}`);
            // Join anyway without mic
            setIsInRoom(true);
            setStatus(`Joined room: ${roomId} (no microphone)`);
            connectToPeer(roomId);
          });
      };

      const createRoom = () => {
        if (!displayName) return;
        
        // Set up audio for all connections
        navigator.mediaDevices.getUserMedia({ audio: true })
          .then(micStream => {
            const audioTrack = micStream.getAudioTracks()[0];
            myMicTrack.current = audioTrack;
            
            setRoomId(myPeerId);
            setIsInRoom(true);
            setStatus(`Created room: ${myPeerId}`);
          })
          .catch(err => {
            setStatus(`Microphone error: ${err.message}`);
            // Create room anyway without mic
            setRoomId(myPeerId);
            setIsInRoom(true);
            setStatus(`Created room: ${myPeerId} (no microphone)`);
          });
      };

      const startScreenShare = async () => {
        try {
          // Get screen stream
          const screenStream = await navigator.mediaDevices.getDisplayMedia({
            video: true,
            audio: true
          });
          
          // Create a combined stream with screen and audio
          const combinedStream = new MediaStream();
          
          // Add all video tracks from screen
          screenStream.getVideoTracks().forEach(track => {
            combinedStream.addTrack(track);
            
            // Listen for the end of screen sharing
            track.addEventListener('ended', () => {
              stopScreenShare();
            });
          });
          
          // Add audio track if available
          if (myMicTrack.current) {
            combinedStream.addTrack(myMicTrack.current);
          }
          
          // Save the stream
          myStream.current = combinedStream;
          
          // Update status
          setIsScreenSharing(true);
          setStatus('Screen sharing started');
          
          // Notify all participants
          Object.values(connections.current).forEach(conn => {
            conn.send({
              type: 'SCREEN_SHARING_STARTED',
              peerId: myPeerId
            });
          });
          
          // Call all participants
          participants.forEach(participant => {
            callPeer(participant.peerId);
          });
        } catch (e) {
          setStatus(`Error: ${e.message}`);
        }
      };

      const stopScreenShare = () => {
        if (!myStream.current) return;
        
        // Stop all tracks
        myStream.current.getTracks().forEach(track => {
          if (track.kind === 'video') {
            track.stop();
          }
        });
        
        // Remove video tracks from the stream
        myStream.current = new MediaStream();
        if (myMicTrack.current) {
          myStream.current.addTrack(myMicTrack.current);
        }
        
        // Update status
        setIsScreenSharing(false);
        setStatus('Screen sharing stopped');
        
        // Notify all participants
        Object.values(connections.current).forEach(conn => {
          conn.send({
            type: 'SCREEN_SHARING_STOPPED',
            peerId: myPeerId
          });
        });
        
        // Close existing calls and restart audio-only calls
        participants.forEach(participant => {
          if (calls.current[participant.peerId]) {
            calls.current[participant.peerId].close();
            delete calls.current[participant.peerId];
          }
          
          // Call with audio only
          if (myMicTrack.current) {
            callPeer(participant.peerId);
          }
        });
      };

      const toggleMute = () => {
        if (myMicTrack.current) {
          const newState = !isAudioMuted;
          myMicTrack.current.enabled = !newState;
          setIsAudioMuted(newState);
        }
      };

      const leaveRoom = () => {
        // Stop screen sharing if active
        if (isScreenSharing) {
          stopScreenShare();
        }
        
        // Close all connections
        Object.values(connections.current).forEach(conn => conn.close());
        connections.current = {};
        
        // Close all calls
        Object.values(calls.current).forEach(call => call.close());
        calls.current = {};
        
        // Clear streams
        streams.current = {};
        
        // Reset state
        setParticipants([]);
        setIsInRoom(false);
        setStatus('Left room');
      };

      // Render a video element for a participant
      const renderParticipantVideo = (participant) => {
        const stream = streams.current[participant.peerId];
        
        if (!stream) return null;
        
        return (
          <div key={participant.peerId} className="mb-4">
            <h3 className="text-sm font-semibold mb-1">
              {participant.displayName} {participant.isScreenSharing ? '(Sharing Screen)' : ''}
            </h3>
            <video
              className="w-full h-auto max-h-40 rounded shadow-lg"
              autoPlay
              playsInline
              ref={el => {
                if (el && stream !== el.srcObject) {
                  el.srcObject = stream;
                }
              }}
            />
          </div>
        );
      };

      return (
        <div className="max-w-md w-full bg-white shadow-lg rounded p-6">
          <h1 className="text-2xl font-bold text-purple-600 mb-4 text-center">SyncLite V24 - Many to Many</h1>
          
          <div className="bg-gray-100 p-3 rounded mb-4 text-sm">
            <p><strong>Status:</strong> {status}</p>
            {myPeerId && <p><strong>Your ID:</strong> {myPeerId}</p>}
            {isInRoom && roomId && <p><strong>Room ID:</strong> {roomId}</p>}
          </div>
          
          {!isInRoom ? (
            <div className="space-y-4">
              <div>
                <label className="block text-sm font-medium mb-1">Display Name</label>
                <input
                  className="border p-2 w-full rounded"
                  placeholder="Enter your name"
                  value={displayName}
                  onChange={e => setDisplayName(e.target.value)}
                />
              </div>
              
              <div>
                <label className="block text-sm font-medium mb-1">Room ID (leave empty to create new room)</label>
                <input
                  className="border p-2 w-full rounded"
                  placeholder="Enter room ID or leave empty"
                  value={roomId}
                  onChange={e => setRoomId(e.target.value)}
                />
              </div>
              
              <div className="flex space-x-2">
                <button
                  onClick={joinRoom}
                  disabled={!roomId || !displayName || !myPeerId}
                  className={`flex-1 py-2 px-4 rounded font-semibold ${
                    roomId && displayName && myPeerId
                      ? 'bg-purple-600 hover:bg-purple-700 text-white'
                      : 'bg-gray-300 text-gray-500 cursor-not-allowed'
                  }`}
                >
                  Join Room
                </button>
                
                <button
                  onClick={createRoom}
                  disabled={!displayName || !myPeerId}
                  className={`flex-1 py-2 px-4 rounded font-semibold ${
                    displayName && myPeerId
                      ? 'bg-green-600 hover:bg-green-700 text-white'
                      : 'bg-gray-300 text-gray-500 cursor-not-allowed'
                  }`}
                >
                  Create Room
                </button>
              </div>
            </div>
          ) : (
            <div className="space-y-4">
              <div className="flex space-x-2">
                {!isScreenSharing ? (
                  <button
                    onClick={startScreenShare}
                    className="flex-1 bg-purple-600 hover:bg-purple-700 text-white py-2 px-4 rounded font-semibold"
                  >
                    Share My Screen
                  </button>
                ) : (
                  <button
                    onClick={stopScreenShare}
                    className="flex-1 bg-red-600 hover:bg-red-700 text-white py-2 px-4 rounded font-semibold"
                  >
                    Stop Sharing
                  </button>
                )}
                
                <button
                  onClick={toggleMute}
                  className={`w-12 py-2 rounded font-semibold ${
                    isAudioMuted
                      ? 'bg-gray-600 hover:bg-gray-700'
                      : 'bg-green-600 hover:bg-green-700'
                  } text-white flex items-center justify-center`}
                >
                  {isAudioMuted ? 'ðŸ”‡' : 'ðŸ”Š'}
                </button>
              </div>
              
              <div className="max-h-96 overflow-y-auto space-y-4">
                <h2 className="text-lg font-semibold">Participants ({participants.length})</h2>
                
                {participants.length === 0 && (
                  <p className="text-gray-500 text-sm">No other participants yet. Share your Room ID: {roomId}</p>
                )}
                
                {participants.map(renderParticipantVideo)}
              </div>
              
              <button
                onClick={leaveRoom}
                className="w-full bg-red-600 hover:bg-red-700 text-white py-2 px-4 rounded font-semibold"
              >
                Leave Room
              </button>
            </div>
          )}
        </div>
      );
    }

    ReactDOM.createRoot(document.getElementById('root')).render(<App />);
  </script>
</body>
</html>