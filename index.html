<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>SyncLite Audio Chat</title>
  <script src="https://cdn.tailwindcss.com"></script>
  <script src="https://unpkg.com/react@18/umd/react.development.js"></script>
  <script src="https://unpkg.com/react-dom@18/umd/react-dom.development.js"></script>
  <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>
  <script src="https://webrtc.github.io/adapter/adapter-latest.js"></script>
  <script src="https://js.pusher.com/8.2.0/pusher.min.js"></script>
</head>
<body>
  <div id="root" class="min-h-screen bg-gray-100 flex flex-col items-center p-4"></div>
  <script type="text/babel">
    const { useState, useEffect, useRef } = React;

    function App() {
      const [userCount, setUserCount] = useState(0);
      const [status, setStatus] = useState('Disconnected');
      const [stream, setStream] = useState(null);
      const [peerConnection, setPeerConnection] = useState(null);
      const pusher = useRef(null);
      const channel = useRef(null);
      const audioRef = useRef(null);
      const videoRef = useRef(null);

      // Initialize Pusher and WebRTC
      useEffect(() => {
        // Connect to Pusher (replace with your app key)
        pusher.current = new Pusher('2d4b87dc9356587cb571', {
          cluster: 'ap2',
          forceTLS: true,
        });

        channel.current = pusher.current.subscribe('synclite-channel');

        // Update user count
        channel.current.bind('pusher:subscription_count', (data) => {
          setUserCount(data.subscription_count);
          if (data.subscription_count >= 2) {
            initWebRTC(false); // Auto-start audio chat with 2 users
          }
        });

        // Handle WebRTC signaling
        channel.current.bind('client-offer', async (data) => {
          if (!peerConnection) await initWebRTC(false);
          await peerConnection.setRemoteDescription(new RTCSessionDescription(data.offer));
          const answer = await peerConnection.createAnswer();
          await peerConnection.setLocalDescription(answer);
          channel.current.trigger('client-answer', { answer });
        });

        channel.current.bind('client-answer', async (data) => {
          if (peerConnection) {
            await peerConnection.setRemoteDescription(new RTCSessionDescription(data.answer));
          }
        });

        channel.current.bind('client-ice-candidate', async (data) => {
          if (peerConnection) {
            await peerConnection.addIceCandidate(new RTCIceCandidate(data.candidate));
          }
        });

        return () => {
          pusher.current.disconnect();
          if (peerConnection) peerConnection.close();
          if (stream) stream.getTracks().forEach((track) => track.stop());
        };
      }, []);

      // Initialize WebRTC
      const initWebRTC = async (isScreenShare = false) => {
        try {
          const pc = new RTCPeerConnection({
            iceServers: [
              { urls: 'stun:stun.l.google.com:19302' },
              { urls: 'stun:stun1.l.google.com:19302' },
              {
                urls: 'turn:openrelay.metered.ca:80',
                username: 'openrelayproject',
                credential: 'openrelayproject',
              },
              {
                urls: 'turn:openrelay.metered.ca:443',
                username: 'openrelayproject',
                credential: 'openrelayproject',
              },
            ],
          });
          setPeerConnection(pc);
          setStatus('Connecting...');

          // Get media
          const media = isScreenShare
            ? await navigator.mediaDevices.getDisplayMedia({ video: true })
            : await navigator.mediaDevices.getUserMedia({ audio: true });
          setStream(media);
          media.getTracks().forEach((track) => pc.addTrack(track, media));

          // Display remote stream
          pc.ontrack = (event) => {
            if (isScreenShare && videoRef.current) {
              videoRef.current.srcObject = event.streams[0];
            } else if (!isScreenShare && audioRef.current) {
              audioRef.current.srcObject = event.streams[0];
            }
            setStatus('Connected');
          };

          // Send ICE candidates
          pc.onicecandidate = (event) => {
            if (event.candidate) {
              channel.current.trigger('client-ice-candidate', { candidate: event.candidate });
            }
          };

          // Create offer for initiator
          const offer = await pc.createOffer();
          await pc.setLocalDescription(offer);
          channel.current.trigger('client-offer', { offer });

          // Monitor ICE state
          pc.oniceconnectionstatechange = () => {
            setStatus(`ICE state: ${pc.iceConnectionState}`);
            if (pc.iceConnectionState === 'failed') {
              setStatus('Connection failed, try different network');
              pc.restartIce();
            }
            if (pc.iceConnectionState === 'connected') {
              setStatus('Connected');
            }
          };

          return pc;
        } catch (e) {
          setStatus(`Error: ${e.message}`);
          alert(`Error: ${e.message}`);
          return null;
        }
      };

      // Start audio chat
      const startAudioChat = async () => {
        if (userCount < 2) {
          alert('Need at least 2 users to start chat');
          return;
        }
        await initWebRTC(false);
      };

      // Start screen sharing
      const startScreenShare = async () => {
        if (userCount < 2) {
          alert('Need at least 2 users to start screen sharing');
          return;
        }
        await initWebRTC(true);
      };

      return (
        <div className="w-full max-w-md">
          <h1 className="text-2xl font-bold mb-4 text-center">SyncLite Audio V5 Chat</h1>
          <p className="text-sm mb-2 text-center">Users on page: {userCount}</p>
          <p className="text-sm mb-2 text-center">Status: {status}</p>
          <button
            onClick={startAudioChat}
            className="bg-green-500 text-white p-2 rounded w-full mb-2"
            disabled={userCount < 2}
          >
            Start Audio Chat
          </button>
          <button
            onClick={startScreenShare}
            className="bg-purple-500 text-white p-2 rounded w-full mb-2"
            disabled={userCount < 2}
          >
            Share Screen
          </button>
          <audio ref={audioRef} autoPlay className="w-full" />
          <video ref={videoRef} autoPlay playsInline className="w-full rounded mt-4" />
        </div>
      );
    }

    ReactDOM.render(<App />, document.getElementById('root'));
  </script>
</body>
</html>