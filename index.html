<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>SyncLite Audio Chat</title>
  <script src="https://cdn.tailwindcss.com"></script>
  <script src="https://unpkg.com/react@18/umd/react.development.js"></script>
  <script src="https://unpkg.com/react-dom@18/umd/react-dom.development.js"></script>
  <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>
  <script src="https://webrtc.github.io/adapter/adapter-latest.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/socket.io/4.7.5/socket.io.min.js"></script>
</head>
<body>
  <div id="root" class="min-h-screen bg-gray-100 flex flex-col items-center p-4"></div>
  <script type="text/babel">
    const { useState, useEffect, useRef } = React;

    function App() {
      const [userCount, setUserCount] = useState(0);
      const [status, setStatus] = useState('Disconnected');
      const [stream, setStream] = useState(null);
      const [peerConnection, setPeerConnection] = useState(null);
      const socket = useRef(null);
      const audioRef = useRef(null);
      const videoRef = useRef(null);

      // Initialize WebSocket and WebRTC
      useEffect(() => {
        // Connect to WebSocket server (replace with your server URL)
        socket.current = io('wss://your-signaling-server-url', { transports: ['websocket'] });

        socket.current.on('connect', () => {
          setStatus('Connected to server');
        });

        // Update user count
        socket.current.on('userCount', (count) => {
          setUserCount(count);
        });

        // Initialize WebRTC when two users are present
        socket.current.on('startWebRTC', () => {
          initWebRTC(false); // Start with audio
        });

        // Handle WebRTC signaling
        socket.current.on('offer', async (offer) => {
          if (!peerConnection) await initWebRTC(false);
          await peerConnection.setRemoteDescription(new RTCSessionDescription(offer));
          const answer = await peerConnection.createAnswer();
          await peerConnection.setLocalDescription(answer);
          socket.current.emit('answer', answer);
        });

        socket.current.on('answer', async (answer) => {
          if (peerConnection) {
            await peerConnection.setRemoteDescription(new RTCSessionDescription(answer));
          }
        });

        socket.current.on('ice-candidate', async (candidate) => {
          if (peerConnection) {
            await peerConnection.addIceCandidate(new RTCIceCandidate(candidate));
          }
        });

        return () => {
          socket.current.disconnect();
          if (peerConnection) peerConnection.close();
          if (stream) stream.getTracks().forEach((track) => track.stop());
        };
      }, []);

      // Initialize WebRTC
      const initWebRTC = async (isScreenShare = false) => {
        try {
          const pc = new RTCPeerConnection({
            iceServers: [
              { urls: 'stun:stun.l.google.com:19302' },
              { urls: 'stun:stun1.l.google.com:19302' },
              { urls: 'stun:stun2.l.google.com:19302' },
              { urls: 'stun:stun3.l.google.com:19302' },
            ],
          });
          setPeerConnection(pc);
          setStatus('Connecting...');

          // Get media
          const media = isScreenShare
            ? await navigator.mediaDevices.getDisplayMedia({ video: true })
            : await navigator.mediaDevices.getUserMedia({ audio: true });
          setStream(media);
          media.getTracks().forEach((track) => pc.addTrack(track, media));

          // Display remote stream
          pc.ontrack = (event) => {
            if (isScreenShare && videoRef.current) {
              videoRef.current.srcObject = event.streams[0];
            } else if (!isScreenShare && audioRef.current) {
              audioRef.current.srcObject = event.streams[0];
            }
            setStatus('Connected');
          };

          // Send ICE candidates
          pc.onicecandidate = (event) => {
            if (event.candidate) {
              socket.current.emit('ice-candidate', event.candidate);
            }
          };

          // Create offer for initiator
          if (!isScreenShare) {
            const offer = await pc.createOffer();
            await pc.setLocalDescription(offer);
            socket.current.emit('offer', offer);
          }

          // Monitor ICE state
          pc.oniceconnectionstatechange = () => {
            setStatus(`ICE state: ${pc.iceConnectionState}`);
            if (pc.iceConnectionState === 'failed') {
              setStatus('Connection failed, try different network');
              pc.restartIce();
            }
            if (pc.iceConnectionState === 'connected') {
              setStatus('Connected');
            }
          };

          return pc;
        } catch (e) {
          setStatus(`Error: ${e.message}`);
          alert(`Error: ${e.message}`);
          return null;
        }
      };

      // Start audio chat
      const startAudioChat = async () => {
        if (userCount < 2) {
          alert('Need at least 2 users to start chat');
          return;
        }
        await initWebRTC(false);
      };

      // Start screen sharing
      const startScreenShare = async () => {
        if (userCount < 2) {
          alert('Need at least 2 users to start screen sharing');
          return;
        }
        await initWebRTC(true);
      };

      return (
        <div className="w-full max-w-md">
          <h1 className="text-2xl font-bold mb-4 text-center">SyncLite Audio V4 Chat</h1>
          <p className="text-sm mb-2 text-center">Users on page: {userCount}</p>
          <p className="text-sm mb-2 text-center">Status: {status}</p>
          <button
            onClick={startAudioChat}
            className="bg-green-500 text-white p-2 rounded w-full mb-2"
            disabled={userCount < 2}
          >
            Start Audio Chat
          </button>
          <button
            onClick={startScreenShare}
            className="bg-purple-500 text-white p-2 rounded w-full mb-2"
            disabled={userCount < 2}
          >
            Share Screen
          </button>
          <audio ref={audioRef} autoPlay className="w-full" />
          <video ref={videoRef} autoPlay playsInline className="w-full rounded mt-4" />
        </div>
      );
    }

    ReactDOM.render(<App />, document.getElementById('root'));
  </script>
</body>
</html>