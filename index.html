<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
  <title>SyncLite Screen Share V26 - Many to Many</title>
  <script src="https://cdn.tailwindcss.com"></script>
  <script src="https://unpkg.com/react@18/umd/react.development.js"></script>
  <script src="https://unpkg.com/react-dom@18/umd/react-dom.development.js"></script>
  <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>
  <script src="https://webrtc.github.io/adapter/adapter-latest.js"></script>
  <script src="https://unpkg.com/peerjs@1.5.2/dist/peerjs.min.js"></script>
</head>
<body>
  <div id="root" class="min-h-screen bg-gray-100 flex flex-col items-center p-4"></div>

  <script type="text/babel">
    const { useState, useEffect, useRef } = React;

    function App() {
      const [roomId, setRoomId] = useState('');
      const [myPeerId, setMyPeerId] = useState('');
      const [displayName, setDisplayName] = useState('');
      const [status, setStatus] = useState('Initializing...');
      const [isInRoom, setIsInRoom] = useState(false);
      const [isScreenSharing, setIsScreenSharing] = useState(false);
      const [isAudioMuted, setIsAudioMuted] = useState(false);
      const [participants, setParticipants] = useState([]);
      const [debugging, setDebugging] = useState('');
      
      const peer = useRef(null);
      const myStream = useRef(null);
      const connections = useRef({});
      const calls = useRef({});
      const streams = useRef({});
      const myMicTrack = useRef(null);
      const myScreenStream = useRef(null);

      // Initialize PeerJS
      useEffect(() => {
        const p = new Peer({
          debug: 3, // For debugging - higher level logs
          config: {
            iceServers: [
              { urls: "stun:stun.relay.metered.ca:80" },
              {
                urls: "turn:global.relay.metered.ca:80",
                username: "openrelayproject",
                credential: "openrelayproject",
              },
              {
                urls: "turn:global.relay.metered.ca:443",
                username: "openrelayproject",
                credential: "openrelayproject",
              },
            ]
          }
        });
        
        // Handle connection events
        p.on('open', id => {
          setMyPeerId(id);
          setStatus('Ready to join or create a room');
        });

        p.on('error', err => {
          setStatus(`PeerJS error: ${err.type} - ${err.message}`);
          addDebugMsg(`PeerJS error: ${err.type} - ${err.message}`);
        });

        // Handle incoming connections
        p.on('connection', conn => {
          handleNewConnection(conn);
        });

        // Handle incoming calls
        p.on('call', call => {
          handleIncomingCall(call);
        });

        peer.current = p;

        return () => {
          // Clean up
          if (myStream.current) {
            myStream.current.getTracks().forEach(track => track.stop());
          }
          
          if (myScreenStream.current) {
            myScreenStream.current.getTracks().forEach(track => track.stop());
          }
          
          // Close all connections
          Object.values(connections.current).forEach(conn => conn.close());
          
          // Close all calls
          Object.values(calls.current).forEach(call => call.close());
          
          p.destroy();
        };
      }, []);

      const addDebugMsg = (msg) => {
        setDebugging(prev => `${msg}\n${prev}`.slice(0, 1000)); // Limit debug history
      };

      const handleNewConnection = (conn) => {
        const peerId = conn.peer;
        
        connections.current[peerId] = conn;
        addDebugMsg(`New connection from: ${peerId}`);
        
        conn.on('open', () => {
          // Send my info to the new participant
          conn.send({
            type: 'USER_INFO',
            peerId: myPeerId,
            displayName: displayName,
            isScreenSharing: isScreenSharing
          });
          
          // Send list of other participants to the new participant
          conn.send({
            type: 'PARTICIPANTS_LIST',
            participants: participants.map(p => ({
              peerId: p.peerId,
              displayName: p.displayName,
              isScreenSharing: p.isScreenSharing
            }))
          });
          
          // Add participant to list if not already present
          addParticipant({
            peerId: peerId,
            displayName: "Unknown", // Will be updated when we get USER_INFO
            isScreenSharing: false,
            hasStream: false
          });
          
          setStatus(`Connected to: ${peerId}`);
          
          // If I'm sharing my screen, initiate a call to the new participant
          if (isScreenSharing && myStream.current) {
            setTimeout(() => {
              callPeer(peerId);
            }, 1000);
          }
        });
        
        conn.on('data', data => {
          handleDataMessage(data, peerId);
        });
        
        conn.on('close', () => {
          removeParticipant(peerId);
          addDebugMsg(`Connection closed with: ${peerId}`);
        });

        conn.on('error', err => {
          addDebugMsg(`Connection error with ${peerId}: ${err.message}`);
        });
      };

      const handleIncomingCall = (call) => {
        const peerId = call.peer;
        addDebugMsg(`Incoming call from: ${peerId}`);
        
        // Answer the call with my audio stream if available, otherwise empty stream
        let answerStream = new MediaStream();
        if (myMicTrack.current) {
          answerStream.addTrack(myMicTrack.current);
        }
        
        call.answer(answerStream);
        calls.current[peerId] = call;
        
        call.on('stream', remoteStream => {
          addDebugMsg(`Received stream from: ${peerId} (tracks: ${remoteStream.getTracks().length})`);
          streams.current[peerId] = remoteStream;
          
          // Update the participants list with the new stream
          setParticipants(prevParticipants => 
            prevParticipants.map(p => 
              p.peerId === peerId ? { ...p, hasStream: true } : p
            )
          );
        });
        
        call.on('close', () => {
          addDebugMsg(`Call closed with: ${peerId}`);
          // Handle call closed
          if (streams.current[peerId]) {
            delete streams.current[peerId];
            
            setParticipants(prevParticipants => 
              prevParticipants.map(p => 
                p.peerId === peerId ? { ...p, hasStream: false } : p
              )
            );
          }
        });

        call.on('error', err => {
          addDebugMsg(`Call error with ${peerId}: ${err.message}`);
        });
      };

      const handleDataMessage = (data, fromPeerId) => {
        if (!data || !data.type) return;
        
        switch (data.type) {
          case 'USER_INFO':
            addDebugMsg(`Received USER_INFO from: ${fromPeerId}, name: ${data.displayName}`);
            // Add new participant to the list or update existing
            setParticipants(prevParticipants => {
              const exists = prevParticipants.some(p => p.peerId === data.peerId);
              if (exists) {
                return prevParticipants.map(p => 
                  p.peerId === data.peerId ? { 
                    ...p, 
                    displayName: data.displayName,
                    isScreenSharing: data.isScreenSharing 
                  } : p
                );
              } else {
                return [...prevParticipants, {
                  peerId: data.peerId,
                  displayName: data.displayName,
                  isScreenSharing: data.isScreenSharing,
                  hasStream: false
                }];
              }
            });
            break;
            
          case 'PARTICIPANTS_LIST':
            addDebugMsg(`Received PARTICIPANTS_LIST from: ${fromPeerId}, count: ${data.participants?.length || 0}`);
            // Add all participants from the list
            if (data.participants && Array.isArray(data.participants)) {
              data.participants.forEach(participant => {
                if (participant.peerId !== myPeerId) {
                  // Add to our participants list
                  addParticipant(participant);
                  
                  // Connect to this participant if not already connected
                  if (!connections.current[participant.peerId]) {
                    connectToPeer(participant.peerId);
                  }
                }
              });
            }
            break;
            
          case 'SCREEN_SHARING_STARTED':
            addDebugMsg(`${fromPeerId} started screen sharing`);
            // Update participant's screen sharing status
            setParticipants(prevParticipants => 
              prevParticipants.map(p => 
                p.peerId === fromPeerId ? { ...p, isScreenSharing: true } : p
              )
            );
            break;
            
          case 'SCREEN_SHARING_STOPPED':
            addDebugMsg(`${fromPeerId} stopped screen sharing`);
            // Update participant's screen sharing status
            setParticipants(prevParticipants => 
              prevParticipants.map(p => 
                p.peerId === fromPeerId ? { ...p, isScreenSharing: false } : p
              )
            );
            break;
            
          default:
            addDebugMsg(`Unknown message type: ${data.type} from ${fromPeerId}`);
            break;
        }
      };

      const addParticipant = (participant) => {
        // Add participant if they don't already exist
        setParticipants(prevParticipants => {
          const exists = prevParticipants.some(p => p.peerId === participant.peerId);
          if (!exists) {
            addDebugMsg(`Adding participant: ${participant.displayName || "Unknown"} (${participant.peerId})`);
            return [...prevParticipants, {
              peerId: participant.peerId,
              displayName: participant.displayName || "Unknown",
              isScreenSharing: participant.isScreenSharing || false,
              hasStream: false
            }];
          }
          return prevParticipants;
        });
      };

      const removeParticipant = (peerId) => {
        addDebugMsg(`Removing participant: ${peerId}`);
        
        // Remove participant from the list
        setParticipants(prevParticipants => 
          prevParticipants.filter(p => p.peerId !== peerId)
        );
        
        // Clean up resources
        if (connections.current[peerId]) {
          connections.current[peerId].close();
          delete connections.current[peerId];
        }
        
        if (calls.current[peerId]) {
          calls.current[peerId].close();
          delete calls.current[peerId];
        }
        
        if (streams.current[peerId]) {
          delete streams.current[peerId];
        }
      };

      const connectToPeer = (remotePeerId) => {
        if (!peer.current || !remotePeerId || remotePeerId === myPeerId) return;
        
        if (connections.current[remotePeerId]) {
          addDebugMsg(`Already connected to ${remotePeerId}, skipping connection`);
          return;
        }
        
        // Create a data connection
        addDebugMsg(`Connecting to peer: ${remotePeerId}`);
        try {
          const conn = peer.current.connect(remotePeerId, {
            reliable: true
          });
          
          connections.current[remotePeerId] = conn;
          
          conn.on('open', () => {
            addDebugMsg(`Connection open to: ${remotePeerId}`);
            // Send my info to the remote peer
            conn.send({
              type: 'USER_INFO',
              peerId: myPeerId,
              displayName: displayName,
              isScreenSharing: isScreenSharing
            });
            
            // If I'm screen sharing, call the remote peer after a short delay
            if (isScreenSharing && myStream.current) {
              setTimeout(() => {
                callPeer(remotePeerId);
              }, 1000);
            }
          });

    ReactDOM.createRoot(document.getElementById('root')).render(<App />);
  </script>
</body>
</html>