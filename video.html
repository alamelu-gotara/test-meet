<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no"/>
  <title>SyncLite Video Chat V3.2 - Audio/iOS Fixes</title>
  <script src="https://cdn.tailwindcss.com"></script>
  <script src="https://unpkg.com/react@18/umd/react.development.js"></script>
  <script src="https://unpkg.com/react-dom@18/umd/react-dom.development.js"></script>
  <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>
  <script src="https://webrtc.github.io/adapter/adapter-latest.js"></script>
  <script src="https://unpkg.com/peerjs@1.5.2/dist/peerjs.min.js"></script>
  <style>
    .no-scrollbar::-webkit-scrollbar { display: none; }
    .no-scrollbar { -ms-overflow-style: none; scrollbar-width: none; }
  </style>
</head>
<body>
  <div id="root" class="min-h-screen bg-gray-900 flex flex-col items-center p-2 sm:p-4 text-white"></div>

  <script type="text/babel">
    const { useState, useRef, useEffect } = React;

    function App() {
      const [peerId, setPeerId] = useState('');
      const [roomId, setRoomId] = useState('');
      const [status, setStatus] = useState('Initializing...');
      const [videos, setVideos] = useState([]); // {peerId, stream, isLocal}
      const [joined, setJoined] = useState(false);
      const [isMuted, setIsMuted] = useState(false);
      const [isVideoEnabled, setIsVideoEnabled] = useState(true);

      const [viewMode, setViewMode] = useState('shared');
      const [mainVideoPeerId, setMainVideoPeerId] = useState(null);

      const peerRef = useRef(null);
      const connectionsRef = useRef({});
      const callsRef = useRef({});
      const localStreamRef = useRef(null);

      useEffect(() => {
        console.log("Initializing PeerJS...");
        const newPeer = new Peer(undefined, {
          host: '0.peerjs.com', // Default PeerJS cloud server
          port: 443,
          path: '/peerjs',
          secure: true,
          debug: 3, // Crucial for debugging connection issues, especially on iOS
        });
        peerRef.current = newPeer;

        newPeer.on('open', id => {
          console.log('PeerJS opened. Peer ID:', id);
          setPeerId(id);
          setStatus('Ready. Share your Peer ID or enter a Room ID to join.');
        });

        newPeer.on('connection', conn => {
          console.log('Incoming data connection from', conn.peer);
          connectionsRef.current[conn.peer] = conn;
          conn.on('data', data => handleSignalingData(data, conn));
          conn.on('close', () => handleDisconnect(conn.peer, 'Data connection closed'));
          conn.on('error', err => {
            console.error('Data connection error with', conn.peer, err);
            handleDisconnect(conn.peer, `Data connection error: ${err.type || err.message}`);
          });
        });

        newPeer.on('call', call => {
          console.log('Incoming call from', call.peer);
          if (localStreamRef.current) {
            console.log('Answering call from', call.peer, 'with local stream.');
            call.answer(localStreamRef.current);
          } else {
            console.warn('Received call from', call.peer, 'but local stream is not ready. Call not answered.');
            // Optionally, you could queue the call or try to get media again, but it's safer if media is ready.
            return; // Do not proceed if local stream isn't available
          }
          
          call.on('stream', remoteStream => {
            console.log('Received remote stream from', call.peer);
            addVideo(call.peer, remoteStream, false);
          });
          callsRef.current[call.peer] = call;
          call.on('close', () => handleDisconnect(call.peer, 'Call closed'));
          call.on('error', (err) => {
            console.error('Call error with', call.peer, err);
            handleDisconnect(call.peer, `Call error: ${err.type || err.message}`);
          });
        });

        newPeer.on('disconnected', () => {
          console.warn('PeerJS disconnected from signaling server.');
          setStatus('Disconnected from PeerJS server. Attempting to reconnect...');
          // PeerJS attempts to reconnect automatically.
        });
        newPeer.on('error', err => {
          console.error('PeerJS general error:', err);
          setStatus(`PeerJS Error: ${err.type} - ${err.message || 'Unknown PeerJS error'}`);
           if (err.type === 'unavailable-id' && roomId) {
             setStatus(`Error: Room Host ID (${roomId}) is not available. Check ID and host status.`);
           } else if (err.type === 'peer-unavailable') {
             const unavailablePeerId = err.message.match(/peer\s(.*?)$/)?.[1];
             setStatus(`Error: Peer ${unavailablePeerId || ''} is unavailable.`);
           } else if (err.type === 'network') {
             setStatus('Network error. Could not connect to PeerJS server. Check internet connection.');
           } else if (err.type === 'webrtc') {
             setStatus('WebRTC connection error. This might be a browser or network issue.');
           }
        });

        return () => {
          console.log('Cleaning up: Closing streams and destroying PeerJS instance.');
          if (localStreamRef.current) {
            localStreamRef.current.getTracks().forEach(track => track.stop());
            localStreamRef.current = null;
          }
          if (peerRef.current) {
            peerRef.current.destroy();
            peerRef.current = null;
          }
          Object.values(callsRef.current).forEach(call => call?.close());
          Object.values(connectionsRef.current).forEach(conn => conn?.close());
          callsRef.current = {};
          connectionsRef.current = {};
        };
      }, []);

      useEffect(() => {
        if (!joined) return;
        const currentMainVideoExists = videos.some(v => v.peerId === mainVideoPeerId);
        if (mainVideoPeerId && !currentMainVideoExists) {
          if (videos.length > 0) {
            const localVideo = videos.find(v => v.isLocal);
            setMainVideoPeerId(localVideo ? localVideo.peerId : videos[0].peerId);
          } else {
            setMainVideoPeerId(null);
          }
        } else if (!mainVideoPeerId && videos.length > 0) {
          const localVideo = videos.find(v => v.isLocal);
          setMainVideoPeerId(localVideo ? localVideo.peerId : videos[0].peerId);
          if (viewMode !== 'shared') setViewMode('shared');
        }
        if (videos.length === 1 && viewMode !== 'shared') {
          setViewMode('shared'); // Ensure shared view if only one participant
        }
      }, [videos, mainVideoPeerId, joined, viewMode]);

      function handleSignalingData(data, conn) {
        console.log('Received signaling data:', data, 'from', conn.peer);
        switch (data.type) {
          case 'join-room': // Received by host from a new joiner
            const currentPeersInRoom = Object.keys(callsRef.current);
            console.log(`Peer ${conn.peer} wants to join. Current peers in room: ${currentPeersInRoom.join(', ')}`);
            conn.send({ type: 'peer-list', peers: currentPeersInRoom });
            
            Object.values(connectionsRef.current).forEach(existingConn => {
              if (existingConn.peer !== conn.peer && existingConn.open) {
                existingConn.send({ type: 'new-peer', peerId: conn.peer });
              }
            });
            if (localStreamRef.current && !callsRef.current[conn.peer]) {
                callPeer(conn.peer);
            } else {
                console.warn("Cannot call new peer, local stream or connection issue.");
            }
            break;
          case 'peer-list': // Received by joiner from host
            console.log('Received peer list:', data.peers);
            data.peers.forEach(pid => {
              if (pid !== peerId && !callsRef.current[pid] && !connectionsRef.current[pid]) {
                connectAndCallPeer(pid);
              }
            });
            break;
          case 'new-peer': // Received by existing peers when a new peer joins
            console.log('New peer announced:', data.peerId);
            if (data.peerId !== peerId && !callsRef.current[data.peerId] && !connectionsRef.current[data.peerId]) {
              connectAndCallPeer(data.peerId);
            }
            break;
          default:
            console.log('Unknown signaling data type:', data.type);
        }
      }

      function addVideo(pId, stream, isLocal = false) {
        console.log(`${isLocal ? 'Local' : 'Remote'} video added for peer: ${pId}`, stream);
        // Log tracks for debugging audio/video issues
        stream.getTracks().forEach(track => {
            console.log(`  Track kind: ${track.kind}, enabled: ${track.enabled}, id: ${track.id}`);
        });

        setVideos(prevVideos => {
          if (prevVideos.some(v => v.peerId === pId)) {
            console.log('Video for peer', pId, 'already exists. Updating stream if necessary.');
            // Optional: update stream if it's different, useful for track changes. For now, just return.
            return prevVideos.map(v => v.peerId === pId ? { ...v, stream } : v);
          }
          return [...prevVideos, { peerId: pId, stream, isLocal }];
        });
      }

      function handleDisconnect(pId, reason = "Unknown reason") {
        console.log(`Handling disconnect for peer: ${pId}. Reason: ${reason}`);
        setVideos(prevVideos => prevVideos.filter(v => v.peerId !== pId));

        if (callsRef.current[pId]) {
          callsRef.current[pId].close();
          delete callsRef.current[pId];
        }
        if (connectionsRef.current[pId]) {
          connectionsRef.current[pId].close();
          delete connectionsRef.current[pId];
        }
         if (mainVideoPeerId === pId) {
             setMainVideoPeerId(null); // Let useEffect handle new main video selection
         }
      }

      async function joinRoom() {
        if (!roomId.trim()) {
          setStatus("Please enter a Room ID or your own Peer ID to host.");
          return;
        }
        setStatus('Starting camera and microphone...');
        try {
          const stream = await navigator.mediaDevices.getUserMedia({ 
            video: true, 
            audio: { echoCancellation: true, noiseSuppression: true } // More robust audio
          });
          console.log('Local media stream obtained:', stream);
          localStreamRef.current = stream;
          stream.getVideoTracks().forEach(track => track.enabled = isVideoEnabled);
          stream.getAudioTracks().forEach(track => track.enabled = !isMuted);

          addVideo(peerId, stream, true);
          setMainVideoPeerId(peerId);
          setViewMode('shared');
          setJoined(true);
          setStatus('Connecting to room...');

          if (roomId !== peerId) { // Joining an existing room
            setMainVideoPeerId(roomId); // Assume host's video will be main initially
            console.log('Attempting to connect to host:', roomId);
            const conn = peerRef.current.connect(roomId);
            if (!conn) {
              setStatus('Failed to initiate connection to host. Peer object might not be ready.');
              setJoined(false);
              return;
            }
            connectionsRef.current[roomId] = conn;
            conn.on('open', () => {
              console.log('Data connection to host opened:', roomId);
              setStatus(`Connected to room ${roomId}. Waiting for others...`);
              conn.send({ type: 'join-room', peerId });
            });
            conn.on('data', data => handleSignalingData(data, conn));
            conn.on('close', () => {
              setStatus(`Disconnected from host ${roomId}.`);
              handleDisconnect(roomId, 'Host data connection closed');
            });
            conn.on('error', err => {
              console.error('Connection to host error', err);
              setStatus(`Error connecting to host ${roomId}: ${err.type || err.message}`);
              handleDisconnect(roomId, `Host connection error: ${err.type || err.message}`);
              setJoined(false); // Could fail to join
            });
          } else { // Hosting a new room
            setStatus(`Hosting room ${peerId}. Share your Peer ID for others to join.`);
            console.log(`Hosting room with ID: ${peerId}`);
          }
        } catch (err) {
          console.error('Failed to get local stream:', err);
          setStatus(`Error: ${err.name} - ${err.message}. Check camera/mic permissions.`);
          if (localStreamRef.current) {
            localStreamRef.current.getTracks().forEach(track => track.stop());
            localStreamRef.current = null;
          }
          setJoined(false);
        }
      }
      
      function callPeer(targetPeerId) {
        if (!localStreamRef.current) {
            console.warn("Local stream not available to make call to", targetPeerId);
            return;
        }
        if (callsRef.current[targetPeerId]) {
            console.log("Already have an active call or call attempt with", targetPeerId);
            return;
        }
        console.log('Calling peer:', targetPeerId);
        const call = peerRef.current.call(targetPeerId, localStreamRef.current);
        if (!call) {
            console.error("Failed to initiate call to", targetPeerId, ". Peer object might not be ready or peer ID invalid.");
            setStatus(`Failed to call ${targetPeerId.substring(0,6)}`);
            return;
        }
        callsRef.current[targetPeerId] = call;
        call.on('stream', remoteStream => {
          console.log('Received stream from outgoing call to', targetPeerId);
          addVideo(targetPeerId, remoteStream, false);
        });
        call.on('close', () => handleDisconnect(targetPeerId, `Outgoing call to ${targetPeerId} closed`));
        call.on('error', (err) => {
            console.error('Outgoing call error with', targetPeerId, err);
            handleDisconnect(targetPeerId, `Outgoing call error with ${targetPeerId}: ${err.type || err.message}`);
        });
      }

      function connectAndCallPeer(targetPeerId) {
        if (targetPeerId === peerId || connectionsRef.current[targetPeerId] || callsRef.current[targetPeerId]) {
          console.log('Skipping connect/call to self or already connected/called peer:', targetPeerId);
          return;
        }
        console.log('Connecting to new peer for signaling then calling:', targetPeerId);
        const conn = peerRef.current.connect(targetPeerId);
         if (!conn) {
            console.error("Failed to initiate data connection to new peer", targetPeerId);
            setStatus(`Failed to connect to ${targetPeerId.substring(0,6)}`);
            return;
        }
        connectionsRef.current[targetPeerId] = conn;
        conn.on('open', () => {
          console.log('Signaling connection established with new peer:', targetPeerId, '. Now calling.');
          callPeer(targetPeerId);
        });
        conn.on('data', data => handleSignalingData(data, conn));
        conn.on('close', () => handleDisconnect(targetPeerId, `Data connection with ${targetPeerId} closed`));
        conn.on('error', err => {
            console.error('Signaling connection error with new peer', targetPeerId, err);
            handleDisconnect(targetPeerId, `Data connection error with ${targetPeerId}: ${err.type || err.message}`);
        });
      }

      function toggleMute() {
        if (localStreamRef.current) {
          const audioTracks = localStreamRef.current.getAudioTracks();
          if (audioTracks.length > 0) {
            const currentMuteState = !audioTracks[0].enabled;
            audioTracks[0].enabled = currentMuteState;
            setIsMuted(!currentMuteState);
            console.log('Toggled mute. Mic enabled:', audioTracks[0].enabled);
          }
        }
      }

      function toggleVideo() {
        if (localStreamRef.current) {
          const videoTracks = localStreamRef.current.getVideoTracks();
          if (videoTracks.length > 0) {
            const newVideoState = !isVideoEnabled;
            videoTracks[0].enabled = newVideoState;
            setIsVideoEnabled(newVideoState);
            console.log('Toggled video. Camera enabled:', videoTracks[0].enabled);
          }
        }
      }

      const mainVideo = videos.find(v => v.peerId === mainVideoPeerId);
      const thumbnailVideos = videos.filter(v => v.peerId !== mainVideoPeerId);
      const remotePeersForDisplay = videos.filter(v => !v.isLocal).map(v => v.peerId.substring(0, 6)).join(', ');
      
      const isOnlyOneOverall = videos.length <= 1; // Used for layout: if 0 or 1 video, main area is 100%

      return (
        <div className="w-full max-w-3xl mx-auto bg-gray-800 shadow-lg rounded-lg p-4 sm:p-6 flex flex-col" style={{height: "calc(100vh - 2rem)", maxHeight: "900px" }}>
          <h1 className="text-2xl sm:text-3xl font-bold text-purple-400 mb-3 text-center">SyncLite Video Chat</h1>
          
          {!joined && (
            <>
              <div className="bg-gray-700 p-3 rounded mb-4 text-xs sm:text-sm space-y-1">
                <p><strong>Your Peer ID:</strong> <span className="text-green-400 break-all">{peerId || 'Initializing...'}</span></p>
                <p><strong>Status:</strong> {status}</p>
              </div>
              <div className="mb-4 space-y-3">
                <input
                  className="border p-3 w-full rounded bg-gray-700 text-white placeholder-gray-400"
                  placeholder="Enter Room Host Peer ID (or your ID to host)"
                  value={roomId}
                  onChange={e => setRoomId(e.target.value)}
                  disabled={!peerId}
                />
                <button
                  onClick={joinRoom}
                  className="bg-purple-600 hover:bg-purple-700 text-white py-3 px-4 rounded w-full font-semibold disabled:bg-gray-500"
                  disabled={!peerId || !roomId.trim()}
                >
                  {roomId === peerId ? 'Start & Host Chat' : 'Join Chat Room'}
                </button>
              </div>
            </>
          )}

          {joined && (
            <>
              <div className="bg-gray-700 p-2 rounded mb-3 text-xs space-y-1">
                <p><strong>Status:</strong> {status}</p>
                <p><strong>My ID:</strong> <span className="text-green-400">{peerId.substring(0,6)}</span>
                  {isMuted ? <span className="text-red-400"> (Mic Off)</span> : <span className="text-green-400"> (Mic On)</span>}
                  {!isVideoEnabled ? <span className="text-yellow-400"> (Cam Off)</span> : <span className="text-blue-400"> (Cam On)</span>}
                </p>
                <p><strong>In Room:</strong> {roomId.substring(0,6)} {roomId === peerId ? "(Hosting)" : ""}</p>
                <p><strong>Remote Peers:</strong> {remotePeersForDisplay || 'None'}</p>
              </div>

              <div className="flex flex-col flex-grow overflow-hidden bg-gray-900 rounded-md">
                {viewMode === 'shared' && mainVideo ? (
                  <div className="flex flex-col h-full">
                    <div className="relative bg-black" style={{ height: isOnlyOneOverall ? '100%' : '65%' }}>
                      { (mainVideo.isLocal && !isVideoEnabled) ? (
                        <div className="w-full h-full flex items-center justify-center bg-black text-gray-400">Your Video Disabled</div>
                      ) : (
                        <video
                          key={mainVideo.peerId + (mainVideo.isLocal && !isVideoEnabled ? '-disabled' : '')} // Add to key to force re-render if necessary
                          autoPlay
                          playsInline
                          muted={mainVideo.isLocal} // Only mute local video to prevent echo
                          ref={el => { if (el) el.srcObject = mainVideo.stream; }}
                          className="w-full h-full object-contain"
                        />
                      )}
                      <span className="absolute bottom-2 left-2 bg-black bg-opacity-60 text-white text-xs px-2 py-1 rounded">
                        {mainVideo.isLocal ? `You (${mainVideo.peerId.substring(0,6)})` : mainVideo.peerId.substring(0,6)}
                        {mainVideo.isLocal && isMuted ? ' (Muted)' : ''}
                        {mainVideo.isLocal && !isVideoEnabled ? ' (Cam Off)' : ''}
                      </span>
                    </div>
                    
                    {/* Thumbnails Area: Only show if NOT onlyOneOverall AND there are actual thumbnails */}
                    {!isOnlyOneOverall && thumbnailVideos.length > 0 && (
                      <div
                        className="flex flex-row gap-2 p-2 overflow-x-auto overflow-y-hidden bg-gray-700 no-scrollbar"
                        style={{ height: '35%', alignItems: 'center' }}
                      >
                        {thumbnailVideos.map(video => (
                          <div
                            key={video.peerId + (video.isLocal && !isVideoEnabled ? '-disabled' : '')}
                            className="relative cursor-pointer rounded overflow-hidden shadow-lg"
                            onClick={() => setMainVideoPeerId(video.peerId)}
                            style={{ flexShrink: 0, width: '120px', height: '90px' }}
                          >
                             { (video.isLocal && !isVideoEnabled) ? (
                                <div className="w-full h-full flex items-center justify-center bg-black text-gray-400 text-xs">Video Off</div>
                              ) : (
                                <video
                                  autoPlay
                                  playsInline
                                  muted={video.isLocal} // Crucial: only mute local video thumbnail
                                  ref={el => { if (el) el.srcObject = video.stream; }}
                                  className="w-full h-full object-cover bg-black"
                                />
                              )}
                            <span className="absolute bottom-1 left-1 bg-black bg-opacity-50 text-white text-xs px-1 rounded">
                              {video.isLocal ? `You (${video.peerId.substring(0,6)})` : video.peerId.substring(0,6)}
                              {video.isLocal && !isVideoEnabled ? ' (Cam Off)' : ''}
                            </span>
                          </div>
                        ))}
                      </div>
                    )}
                    {/* Placeholder if multiple participants expected, but no thumbnails (e.g., only main video exists out of multiple) */}
                     {!isOnlyOneOverall && thumbnailVideos.length === 0 && videos.length > 1 && (
                         <div className="h-[35%] flex items-center justify-center text-gray-500 text-sm bg-gray-700">
                             <p>No other participants in thumbnail view.</p>
                         </div>
                     )}
                  </div>
                ) : viewMode === 'grid' && videos.length > 0 ? (
                  <div className="flex-grow grid grid-cols-1 sm:grid-cols-2 gap-2 p-2 overflow-y-auto">
                    {videos.map(video => (
                      <div
                        key={video.peerId + (video.isLocal && !isVideoEnabled ? '-disabled' : '')}
                        className="relative cursor-pointer rounded overflow-hidden shadow-lg bg-black aspect-[4/3]"
                        onClick={() => {
                          setMainVideoPeerId(video.peerId);
                          setViewMode('shared');
                        }}
                      >
                        { (video.isLocal && !isVideoEnabled) ? (
                          <div className="w-full h-full flex items-center justify-center bg-black text-gray-400">Video Disabled</div>
                        ) : (
                          <video
                            autoPlay
                            playsInline
                            muted={video.isLocal} // Only mute local video in grid
                            ref={el => { if (el) el.srcObject = video.stream; }}
                            className="w-full h-full object-cover"
                          />
                        )}
                        <span className="absolute bottom-2 left-2 bg-black bg-opacity-60 text-white text-xs px-2 py-1 rounded">
                          {video.isLocal ? `You (${video.peerId.substring(0,6)})` : video.peerId.substring(0,6)}
                          {video.isLocal && isMuted ? ' (Muted)' : ''}
                          {video.isLocal && !isVideoEnabled ? ' (Cam Off)' : ''}
                        </span>
                      </div>
                    ))}
                  </div>
                ) : (
                   <div className="flex-grow flex items-center justify-center text-gray-400">
                       <p>{videos.length === 0 ? "Waiting for participants..." : (mainVideo ? "Main video selected" : "No participants or main video.")}</p>
                   </div>
                )}
              </div>

              <div className="mt-3 grid grid-cols-2 sm:grid-cols-3 gap-2 sm:gap-3">
                <button
                  onClick={toggleMute}
                  className={`py-2 px-3 text-xs sm:text-sm rounded font-semibold flex-1 ${isMuted ? 'bg-red-600 hover:bg-red-700' : 'bg-green-600 hover:bg-green-700'} text-white`}
                >
                  {isMuted ? 'Unmute Mic' : 'Mute Mic'}
                </button>
                <button
                  onClick={toggleVideo}
                  className={`py-2 px-3 text-xs sm:text-sm rounded font-semibold flex-1 ${!isVideoEnabled ? 'bg-yellow-600 hover:bg-yellow-700' : 'bg-blue-600 hover:bg-blue-700'} text-white`}
                >
                  {isVideoEnabled ? 'Disable Video' : 'Enable Video'}
                </button>
                {videos.length > 1 && (
                  <button
                    onClick={() => setViewMode(prev => prev === 'grid' ? 'shared' : 'grid')}
                    className="py-2 px-3 text-xs sm:text-sm rounded font-semibold bg-indigo-600 hover:bg-indigo-700 text-white flex-1 sm:col-start-3" // Ensure it takes full width on sm if it's the 3rd item
                  >
                    {viewMode === 'grid' ? 'Shared View' : 'Grid View'}
                  </button>
                )}
              </div>
            </>
          )}
        </div>
      );
    }

    ReactDOM.createRoot(document.getElementById('root')).render(<App />);
  </script>
</body>
</html>
