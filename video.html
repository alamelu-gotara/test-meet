<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no"/>
  <title>SyncLite Pro Video Chat - V4.1</title>
  {/* ... (rest of head is same) ... */}
  <script src="https://cdn.tailwindcss.com"></script>
  <script src="https://unpkg.com/react@18/umd/react.development.js"></script>
  <script src="https://unpkg.com/react-dom@18/umd/react-dom.development.js"></script>
  <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>
  <script src="https://webrtc.github.io/adapter/adapter-latest.js"></script>
  <script src="https://unpkg.com/peerjs@1.5.2/dist/peerjs.min.js"></script>
  <style>
    body { -webkit-font-smoothing: antialiased; -moz-osx-font-smoothing: grayscale; }
    .no-scrollbar::-webkit-scrollbar { display: none; }
    .no-scrollbar { -ms-overflow-style: none; scrollbar-width: none; }
    .video-container { position: relative; background-color: #1a202c; overflow: hidden; border-radius: 0.375rem; width: 100%; height: 100%; }
    .participant-name {
      position: absolute; bottom: 6px; left: 6px; background-color: rgba(0, 0, 0, 0.75);
      color: white; font-size: 0.7rem; padding: 3px 8px; border-radius: 0.25rem;
      max-width: calc(100% - 12px); overflow: hidden; text-overflow: ellipsis; white-space: nowrap; z-index: 10;
    }
    .video-element { width: 100%; height: 100%; display: block; }
    .disabled-video-placeholder, .remote-media-off-placeholder {
      width: 100%; height: 100%; display: flex; flex-direction: column;
      align-items: center; justify-content: center; background-color: #2d3748;
      color: #a0aec0; font-size: 0.875rem; text-align: center; padding: 0.5rem;
    }
    .media-status-icon {
        position: absolute; top: 8px; right: 8px; background-color: rgba(0,0,0,0.6);
        border-radius: 50%; padding: 4px; z-index: 15; display: flex; gap: 4px;
    }
     .local-media-status-icon {
        position: absolute; top: 8px; left: 8px; background-color: rgba(0,0,0,0.6);
        border-radius: 50%; padding: 4px; z-index: 15; display: flex; gap: 4px;
    }
    .status-bar {
        position: absolute; top: 8px; left: 50%; transform: translateX(-50%);
        background-color: rgba(26, 32, 44, 0.8); color: white; padding: 6px 12px; 
        border-radius: 8px; font-size: 0.75rem; z-index: 20; display: flex;
        align-items: center; gap: 10px; box-shadow: 0 2px 4px rgba(0,0,0,0.2);
    }
    .status-bar .timer { font-weight: 500; }
    .status-bar .network-info { display: flex; align-items: center; gap: 4px; }
  </style>
</head>
<body>
  <div id="root" class="min-h-screen bg-gray-900 flex flex-col items-center text-white"></div>

  <script type="text/babel">
    const { useState, useRef, useEffect, useCallback, memo } = React;

    // --- Icon Components (memoized, same as V4.0) ---
    const MicOnIcon = memo(() => <svg xmlns="http://www.w3.org/2000/svg" className="h-4 w-4" fill="none" viewBox="0 0 24 24" stroke="currentColor"><path strokeLinecap="round" strokeLinejoin="round" strokeWidth="2" d="M19 11a7 7 0 01-7 7m0 0a7 7 0 01-7-7m7 7v4m0 0H8m4 0h4m-4-8a3 3 0 01-3-3V5a3 3 0 116 0v6a3 3 0 01-3 3z" /></svg>);
    const MicOffIcon = memo(() => <svg xmlns="http://www.w3.org/2000/svg" className="h-4 w-4" fill="none" viewBox="0 0 24 24" stroke="currentColor"><path strokeLinecap="round" strokeLinejoin="round" strokeWidth="2" d="M19 11a7 7 0 01-7 7m0 0a7 7 0 01-7-7m7 7v4m0 0H8m4 0h4m-4-8a3 3 0 01-3-3V5a3 3 0 116 0v6a3 3 0 01-3 3zM12 18.5A4.5 4.5 0 0016.5 14H8a4.5 4.5 0 004 4.5zM6 18L18 6M6 6l12 12" /></svg>); 
    const VideoOnIcon = memo(() => <svg xmlns="http://www.w3.org/2000/svg" className="h-5 w-5 sm:h-6 sm:w-6" fill="none" viewBox="0 0 24 24" stroke="currentColor"><path strokeLinecap="round" strokeLinejoin="round" strokeWidth="2" d="M15 10l4.553-2.276A1 1 0 0121 8.618v6.764a1 1 0 01-1.447.894L15 14M4 8h11a1 1 0 011 1v6a1 1 0 01-1 1H4a1 1 0 01-1-1V9a1 1 0 011-1z" /></svg>);
    const VideoCamIcon = memo(() => <svg xmlns="http://www.w3.org/2000/svg" className="h-4 w-4" fill="none" viewBox="0 0 24 24" stroke="currentColor"><path strokeLinecap="round" strokeLinejoin="round" strokeWidth="2" d="M15 10l4.553-2.276A1 1 0 0121 8.618v6.764a1 1 0 01-1.447.894L15 14M4 8h11a1 1 0 011 1v6a1 1 0 01-1 1H4a1 1 0 01-1-1V9a1 1 0 011-1z" /></svg>);
    const VideoOffIcon = memo(() => <svg xmlns="http://www.w3.org/2000/svg" className="h-5 w-5 sm:h-6 sm:w-6" fill="none" viewBox="0 0 24 24" stroke="currentColor"><path strokeLinecap="round" strokeLinejoin="round" strokeWidth="2" d="M15 10l4.553-2.276A1 1 0 0121 8.618v6.764a1 1 0 01-1.447.894L15 14M4 8h11a1 1 0 011 1v6a1 1 0 01-1 1H4a1 1 0 01-1-1V9a1 1 0 011-1zm0 0l6.364-3.182M10.364 4.818L4 8m6.364-3.182l-1.455-2.723M6 18L18 6M6 6l12 12" /></svg>);
    const VideoCamOffIcon = memo(() => <svg xmlns="http://www.w3.org/2000/svg" className="h-4 w-4" fill="none" viewBox="0 0 24 24" stroke="currentColor"><path strokeLinecap="round" strokeLinejoin="round" strokeWidth="2" d="M15 10l4.553-2.276A1 1 0 0121 8.618v6.764a1 1 0 01-1.447.894L15 14M4 8h11a1 1 0 011 1v6a1 1 0 01-1 1H4a1 1 0 01-1-1V9a1 1 0 011-1zm0 0l6.364-3.182M10.364 4.818L4 8m6.364-3.182l-1.455-2.723M6 18L18 6M6 6l12 12" /></svg>);
    const GalleryLayoutIcon = memo(() => <svg xmlns="http://www.w3.org/2000/svg" className="h-5 w-5 sm:h-6 sm:w-6" fill="none" viewBox="0 0 24 24" stroke="currentColor"><path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M4 6a2 2 0 012-2h2a2 2 0 012 2v2a2 2 0 01-2 2H6a2 2 0 01-2-2V6zM14 6a2 2 0 012-2h2a2 2 0 012 2v2a2 2 0 01-2 2h-2a2 2 0 01-2-2V6zM4 16a2 2 0 012-2h2a2 2 0 012 2v2a2 2 0 01-2 2H6a2 2 0 01-2-2v-2zM14 16a2 2 0 012-2h2a2 2 0 012 2v2a2 2 0 01-2 2h-2a2 2 0 01-2-2v-2z" /></svg>);
    const SpeakerLayoutIcon = memo(() => <svg xmlns="http://www.w3.org/2000/svg" className="h-5 w-5 sm:h-6 sm:w-6" fill="none" viewBox="0 0 24 24" stroke="currentColor"><path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M4 6h16M4 12h16M4 18h7" /></svg>);
    const EndCallIcon = memo(() => <svg xmlns="http://www.w3.org/2000/svg" className="h-5 w-5 sm:h-6 sm:w-6" viewBox="0 0 20 20" fill="currentColor"><path fillRule="evenodd" d="M10 18a8 8 0 100-16 8 8 0 000 16zM7.707 7.707a1 1 0 011.414-1.414L10 8.586l.879-.879a1 1 0 111.414 1.414L11.414 10l.879.879a1 1 0 01-1.414 1.414L10 11.414l-.879.879a1 1 0 01-1.414-1.414L8.586 10 7.707 9.121A1 1 0 017.707 7.707z" clipRule="evenodd" /></svg>);
    const ClockIcon = memo(() => <svg xmlns="http://www.w3.org/2000/svg" className="h-4 w-4" fill="none" viewBox="0 0 24 24" stroke="currentColor" strokeWidth={2}><path strokeLinecap="round" strokeLinejoin="round" d="M12 8v4l3 3m6-3a9 9 0 11-18 0 9 9 0 0118 0z" /></svg>);
    const WifiIcon = memo(() => <svg xmlns="http://www.w3.org/2000/svg" className="h-4 w-4" fill="none" viewBox="0 0 24 24" stroke="currentColor" strokeWidth={2}><path strokeLinecap="round" strokeLinejoin="round" d="M8.111 16.059A7.5 7.5 0 0112 15c1.599 0 3.078.504 4.332 1.342m3.236-3.307a12.024 12.024 0 00-15.136 0M21 12a9 9 0 11-18 0 9 9 0 0118 0z" /></svg>);
    const SignalIcon = memo(() => <svg xmlns="http://www.w3.org/2000/svg" className="h-4 w-4" fill="none" viewBox="0 0 24 24" stroke="currentColor" strokeWidth={2}><path strokeLinecap="round" strokeLinejoin="round" d="M7 4v16M12 9v11M17 13v7" /></svg>); 

    // --- Child Components (Memoized) ---
    const VideoPlaceholder = memo(({ text }) => ( <div className="disabled-video-placeholder"><VideoCamOffIcon /> <span className="mt-2">{text}</span></div>));
    const RemoteMediaOffPlaceholder = memo(({ text, isAudioOff, isVideoOff }) => (
      <div className="remote-media-off-placeholder">
          {isVideoOff && <VideoCamOffIcon />}
          {isAudioOff && !isVideoOff && <MicOffIcon />}
          <span className="mt-2 text-xs">{text}</span>
      </div>
    ));
    
    // VideoPlayer: Pass global isMuted and isVideoEnabled for local user's display consistency
    const VideoPlayer = memo(({ videoData, isLocalVideoGloballyEnabled, isLocalAudioGloballyMuted }) => { 
      const { peerId: videoPeerId, stream, isLocal, name, audioEnabled, videoEnabled: participantVideoEnabled } = videoData;
      const videoRef = useRef(null); 
      
      useEffect(() => { 
          if (videoRef.current && stream) videoRef.current.srcObject = stream; 
          else if (videoRef.current) videoRef.current.srcObject = null;
      }, [stream]); 
      
      const actualIsLocalVideoOn = isLocal ? isLocalVideoGloballyEnabled : true; 

      if (isLocal && !actualIsLocalVideoOn) {
           return <VideoPlaceholder text="Your camera is off" />;
      }
      if (!isLocal && !participantVideoEnabled) {
          return <RemoteMediaOffPlaceholder text={`${name}'s camera is off`} isVideoOff={true} isAudioOff={!audioEnabled} />;
      }
      if (!stream) {
          return <RemoteMediaOffPlaceholder text={`${name} (Connecting...)`} isVideoOff={!participantVideoEnabled} isAudioOff={!audioEnabled}/>;
      }

      return (
        <div className="w-full h-full relative video-container-instance" data-peer-id={videoPeerId}>
          <video ref={videoRef} autoPlay playsInline muted={isLocal} className="video-element object-cover" />
          {name && <div className="participant-name">{name}</div>}
          {!isLocal && (!audioEnabled || !participantVideoEnabled) && (
              <div className="media-status-icon">
                  {!audioEnabled && <MicOffIcon />}
                  {!participantVideoEnabled && audioEnabled && <VideoCamOffIcon/>}
              </div>
          )}
          {isLocal && isLocalAudioGloballyMuted && actualIsLocalVideoOn && ( // Show mute icon on own video if muted and cam is on
              <div className="local-media-status-icon"> <MicOffIcon /> </div>
          )}
        </div>
      );
    }, (prevProps, nextProps) => { // Custom comparison for VideoPlayer
        const p = prevProps.videoData;
        const n = nextProps.videoData;
        let localPropsSame = true;
        if (p.isLocal) { // Only check global states if it's the local player
            localPropsSame = prevProps.isLocalVideoGloballyEnabled === nextProps.isLocalVideoGloballyEnabled &&
                             prevProps.isLocalAudioGloballyMuted === nextProps.isLocalAudioGloballyMuted;
        }
        return p.stream === n.stream &&
               p.name === n.name &&
               p.audioEnabled === n.audioEnabled &&
               p.videoEnabled === n.videoEnabled &&
               p.isLocal === n.isLocal &&
               p.peerId === n.peerId &&
               localPropsSame;
    });

    const ControlButton = memo(({ title, onClick, children, active = false, activeColor = "bg-red-500", defaultColor = "bg-gray-600 hover:bg-gray-500" }) => ( <button title={title} onClick={onClick} className={`p-2.5 sm:p-3 rounded-full text-white transition-colors duration-150 ease-in-out ${active ? activeColor : defaultColor} focus:outline-none focus:ring-2 focus:ring-purple-500 focus:ring-opacity-50`}>{children}</button>));
    
    const Controls = memo(({ isMuted, isVideoEnabled, onToggleMute, onToggleVideo, onToggleLayout, onEndCall, videoCount, currentViewMode }) => {
      return (
          <div className="flex justify-center items-center space-x-2 sm:space-x-3">
              <ControlButton title={isMuted ? "Unmute" : "Mute"} onClick={onToggleMute} active={isMuted}>
                  {isMuted ? <MicOffIcon/> : <MicOnIcon/>}
              </ControlButton>
              <ControlButton title={isVideoEnabled ? "Cam Off" : "Cam On"} onClick={onToggleVideo} active={!isVideoEnabled}>
                  {isVideoEnabled ? <VideoOnIcon/> : <VideoOffIcon/>}
              </ControlButton>
              {videoCount > 1 && (
                  <ControlButton title={currentViewMode === 'gallery' ? "Speaker View" : "Gallery View"} onClick={onToggleLayout}>
                      {currentViewMode === 'gallery' ? <SpeakerLayoutIcon/> : <GalleryLayoutIcon/>}
                  </ControlButton>
              )}
              <ControlButton title="End Call" onClick={onEndCall} defaultColor="bg-red-600 hover:bg-red-700">
                  <EndCallIcon/>
              </ControlButton>
          </div>
      );
    });

    const StatusBar = memo(({currentTime, userDisplayName, currentNetworkType, formatTimeFunc}) => {
      return (
          <div className="status-bar">
              <ClockIcon /> <span className="timer">{formatTimeFunc(currentTime)}</span>
              <span className="mx-1 opacity-50">|</span>
              <span className="truncate max-w-[100px] sm:max-w-[150px]" title={userDisplayName}>{userDisplayName}</span>
              {(currentNetworkType && currentNetworkType !== 'N/A' && currentNetworkType !== 'loading...') && (
                  <> <span className="mx-1 opacity-50">|</span> <span className="network-info">
                      {currentNetworkType === 'cellular' ? <SignalIcon /> : <WifiIcon />}
                      <span className="capitalize">{currentNetworkType}</span>
                  </span> </>
              )}
          </div>
      );
    });

    // --- NEW: VideoLayout Component ---
    const VideoLayout = memo(({ 
        videos, viewMode, activeSpeakerId, 
        isLocalVideoGloballyEnabled, isLocalAudioGloballyMuted, // Pass global states for local VideoPlayer
        onSetActiveSpeaker, onSetViewMode 
    }) => {
        console.log("VideoLayout rendering. Videos count:", videos.length); // Debug VideoLayout re-renders
        const activeSpeakerData = videos.find(v => v.peerId === activeSpeakerId);
        const filmstripVideosData = videos.filter(v => v.peerId !== activeSpeakerId);
        const galleryGridVideosData = videos;

        const galleryCols = galleryGridVideosData.filter(v=>v.stream || v.isLocal).length <= 1 ? 1 : (galleryGridVideosData.filter(v=>v.stream || v.isLocal).length <= 4 ? 2 : (galleryGridVideosData.filter(v=>v.stream || v.isLocal).length <= 9 ? 3 : 4));
        
        return (
            <div className="flex-grow flex flex-col bg-black p-1 sm:p-2 min-h-0 mt-10 sm:mt-12">
            {viewMode === 'speaker' ? (
              <div className="flex flex-col flex-grow h-full space-y-1 sm:space-y-2 min-h-0">
                <div className="flex-grow video-container min-h-0">
                  {activeSpeakerData ? (
                    <VideoPlayer 
                        videoData={activeSpeakerData} 
                        isLocalVideoGloballyEnabled={isLocalVideoGloballyEnabled} 
                        isLocalAudioGloballyMuted={isLocalAudioGloballyMuted}
                    />
                  ) : <VideoPlaceholder text={videos.length > 0 ? "Select participant" : "Waiting..."} />}
                </div>
                {filmstripVideosData.filter(v => v.stream || v.isLocal).length > 0 && (
                   <div className="flex-shrink-0 h-24 sm:h-32 bg-gray-800 p-1 sm:p-2 flex space-x-1 sm:space-x-2 overflow-x-auto no-scrollbar items-center rounded-md">
                    {filmstripVideosData.map(video => (
                      (video.stream || video.isLocal) &&
                      <div key={video.peerId} className="video-container w-28 sm:w-40 h-full cursor-pointer border-2 border-transparent hover:border-purple-500"
                        onClick={() => onSetActiveSpeaker(video.peerId)} tabIndex="0">
                        <VideoPlayer 
                            videoData={video}
                            isLocalVideoGloballyEnabled={isLocalVideoGloballyEnabled}
                            isLocalAudioGloballyMuted={isLocalAudioGloballyMuted}
                        />
                      </div>
                    ))}
                  </div>
                )}
              </div>
            ) : ( 
              <div className={`flex-grow p-1 sm:p-2 grid gap-1 sm:gap-2 overflow-y-auto grid-cols-${galleryCols} min-h-0`}>
                {galleryGridVideosData.map(video => (
                   (video.stream || video.isLocal) &&
                  <div key={video.peerId} className="video-container aspect-video"
                    onClick={() => { onSetActiveSpeaker(video.peerId); onSetViewMode('speaker');}} tabIndex="0">
                    <VideoPlayer 
                        videoData={video} 
                        isLocalVideoGloballyEnabled={isLocalVideoGloballyEnabled}
                        isLocalAudioGloballyMuted={isLocalAudioGloballyMuted}
                    />
                  </div>
                ))}
                 {galleryGridVideosData.filter(v=>v.stream || v.isLocal).length === 0 && <div className="disabled-video-placeholder col-span-full row-span-full"><VideoPlaceholder text="No one here" /></div>}
              </div>
            )}
          </div>
        );
    });


    function App() {
      const [peerId, setPeerId] = useState('');
      const [roomId, setRoomId] = useState('');
      const [displayName, setDisplayName] = useState(`User-${Math.random().toString(36).substring(2, 6)}`);
      const [status, setStatus] = useState('Initializing Peer Connection...');
      const [videos, setVideos] = useState([]); 
      const [joined, setJoined] = useState(false);
      const [isMuted, setIsMuted] = useState(false); // Local mute state
      const [isVideoEnabled, setIsVideoEnabled] = useState(true); // Local video state
      const [viewMode, setViewMode] = useState('speaker'); 
      const [activeSpeakerId, setActiveSpeakerId] = useState(null); 
      const [callStartTime, setCallStartTime] = useState(null);
      const [elapsedTime, setElapsedTime] = useState(0); 
      const [networkType, setNetworkType] = useState('loading...');

      const peerRef = useRef(null);
      const connectionsRef = useRef({});
      const callsRef = useRef({});
      const localStreamRef = useRef(null);
      const timerIntervalRef = useRef(null);

      // PeerJS, Timer, Network listeners (same as V4.0, ensure they don't cause App to re-render unnecessarily if possible)
      useEffect(() => { /* PeerJS init */
        console.log("App PeerJS useEffect running");
        if (peerRef.current) peerRef.current.destroy();
        const newPeerInstance = new Peer(undefined, { debug: 3 });
        peerRef.current = newPeerInstance;

        newPeerInstance.on('open', (id) => { setPeerId(id); setStatus('Ready.'); });
        newPeerInstance.on('connection', (conn) => {
          if (!peerRef.current || peerRef.current.disconnected || peerRef.current !== newPeerInstance) return;
          const remotePeerId = conn.peer;
          const remoteMeta = conn.metadata || {};
          connectionsRef.current[remotePeerId] = conn;
          const initialName = remoteMeta.displayName || `Peer-${remotePeerId.substring(0,4)}`;
          updateOrAddParticipant(remotePeerId, null, initialName, remoteMeta.audioEnabled !== false, remoteMeta.videoEnabled !== false);
          conn.on('data', data => handleSignalingData(data, conn));
          conn.on('close', () => handleDisconnect(remotePeerId, 'Data conn closed'));
          conn.on('error', err => handleDisconnect(remotePeerId, `Data conn error: ${err.type}`));
        });
        newPeerInstance.on('call', (call) => {
          if (!peerRef.current || peerRef.current.disconnected || peerRef.current !== newPeerInstance) return;
          const remotePeerId = call.peer;
          const remoteMeta = call.metadata || {};
          if (localStreamRef.current) {
            call.answer(localStreamRef.current, { metadata: { displayName, audioEnabled: !isMuted, videoEnabled: isVideoEnabled } });
          } else { return; }
          callsRef.current[remotePeerId] = call;
          const initialName = remoteMeta.displayName || `Peer-${remotePeerId.substring(0,4)}`;
          updateOrAddParticipant(remotePeerId, null, initialName, remoteMeta.audioEnabled !== false, remoteMeta.videoEnabled !== false);
          call.on('stream', remoteStream => {
            const currentMeta = call.metadata || {};
            updateOrAddParticipant(remotePeerId, remoteStream, currentMeta.displayName || initialName, currentMeta.audioEnabled !== false, currentMeta.videoEnabled !== false);
          });
          call.on('close', () => handleDisconnect(remotePeerId, 'Call closed'));
          call.on('error', (err) => handleDisconnect(remotePeerId, `Call error: ${err.type}`));
        });
        newPeerInstance.on('disconnected', () => { if (peerRef.current === newPeerInstance && !peerRef.current.destroyed) setStatus('Signaling server disconnected. Reconnecting...'); });
        newPeerInstance.on('close', () => console.log('PeerJS: "close" event (peer destroyed).'));
        newPeerInstance.on('error', (err) => { console.error('PeerJS Error:', err); if (peerRef.current === newPeerInstance && !peerRef.current.destroyed) setStatus(`PeerJS Error: ${err.type}`);});

        return () => {
            console.log("App cleanup: Destroying PeerJS and clearing resources.");
            newPeerInstance.destroy(); 
            if (peerRef.current === newPeerInstance) peerRef.current = null; 
            Object.values(callsRef.current).forEach(c => c.close());
            Object.values(connectionsRef.current).forEach(c => c.close());
            callsRef.current = {}; connectionsRef.current = {};
            localStreamRef.current?.getTracks().forEach(track => track.stop());
            localStreamRef.current = null;
            clearInterval(timerIntervalRef.current); // Clear timer here too
        };
      }, [displayName]); // displayName is a dependency for metadata

      useEffect(() => { /* Timer effect */
        console.log("App Timer useEffect running");
        if (joined && callStartTime) {
          timerIntervalRef.current = setInterval(() => {
            setElapsedTime(prevTime => prevTime + 1);
          }, 1000);
        } else {
          clearInterval(timerIntervalRef.current);
          setElapsedTime(0);
        }
        return () => clearInterval(timerIntervalRef.current);
      }, [joined, callStartTime]);

      useEffect(() => { /* Network connection listener */
        console.log("App Network useEffect running");
        const updateNetworkInfo = () => {
          if (navigator.connection) {
            setNetworkType(navigator.connection.type || 'N/A');
          } else {
            setNetworkType('N/A');
          }
        };
        updateNetworkInfo();
        if (navigator.connection) navigator.connection.addEventListener('change', updateNetworkInfo);
        return () => { if (navigator.connection) navigator.connection.removeEventListener('change', updateNetworkInfo);};
      }, []);
      
      // --- Callbacks (memoized) ---
      const updateOrAddParticipant = useCallback((pId, stream = null, name = null, audioEnabled = true, videoEnabled = true, isLocal = false) => {
        console.log(`updateOrAddParticipant called for ${pId} (${name})`);
        setVideos(prevVideos => {
          const existingVidIndex = prevVideos.findIndex(v => v.peerId === pId);
          let finalName = name;
          if (!finalName) {
            if (existingVidIndex !== -1) finalName = prevVideos[existingVidIndex].name;
            else finalName = isLocal ? displayName : `Peer-${pId.substring(0,4)}`;
          }
          
          if (existingVidIndex !== -1) {
            const currentVid = prevVideos[existingVidIndex];
            if (currentVid.stream === stream && currentVid.name === finalName && 
                currentVid.audioEnabled === audioEnabled && currentVid.videoEnabled === videoEnabled &&
                currentVid.isLocal === isLocal) {
                return prevVideos; 
            }
            const updatedVid = { ...currentVid, name: finalName, audioEnabled, videoEnabled, isLocal };
            if (stream !== undefined) updatedVid.stream = stream;

            const newVideos = [...prevVideos];
            newVideos[existingVidIndex] = updatedVid;
            return newVideos;
          } else {
            return [...prevVideos, { peerId: pId, stream, name: finalName, isLocal, audioEnabled, videoEnabled }];
          }
        });
         if (isLocal && !activeSpeakerId && stream) setActiveSpeakerId(pId);
      }, [displayName, activeSpeakerId]); // Added activeSpeakerId
      
      const broadcastMediaStatus = useCallback(() => {
        const statusPayload = { type: 'media-status-update', audioEnabled: !isMuted, videoEnabled: isVideoEnabled };
        Object.values(connectionsRef.current).forEach(conn => { if (conn.open) conn.send(statusPayload); });
       }, [isMuted, isVideoEnabled]);

      const handleSignalingData = useCallback((data, conn) => {
        const senderPeerId = conn.peer;
        const senderMeta = conn.metadata || {};
        const senderDisplayName = data.name || senderMeta.displayName || `Peer-${senderPeerId.substring(0,4)}`;

        switch (data.type) {
          case 'join-request':
            updateOrAddParticipant(senderPeerId, null, senderDisplayName, data.audioEnabled !== false, data.videoEnabled !== false);
            const currentPeers = videos.filter(v => v.peerId !== peerId)
                .map(v => ({ peerId: v.peerId, name: v.name, audioEnabled: v.audioEnabled, videoEnabled: v.videoEnabled }));
            conn.send({ type: 'room-info', peers: currentPeers, hostName: displayName, startTime: callStartTime || Date.now() });
            Object.values(connectionsRef.current).forEach(c => {
              if (c.peer !== senderPeerId && c.open) {
                c.send({ type: 'new-peer', peerId: senderPeerId, name: senderDisplayName, audioEnabled: data.audioEnabled !== false, videoEnabled: data.videoEnabled !== false });
              }
            });
            if (localStreamRef.current && !callsRef.current[senderPeerId]) callPeer(senderPeerId, senderDisplayName);
            break;
          case 'room-info': 
            if (data.startTime && !callStartTime) setCallStartTime(data.startTime);
            data.peers.forEach(pInfo => {
              updateOrAddParticipant(pInfo.peerId, null, pInfo.name, pInfo.audioEnabled !== false, pInfo.videoEnabled !== false);
              if (!callsRef.current[pInfo.peerId]) connectAndCallPeer(pInfo.peerId, pInfo.name);
            });
            updateOrAddParticipant(senderPeerId, null, data.hostName, senderMeta.audioEnabled !== false, senderMeta.videoEnabled !== false);
            break;
          case 'new-peer': 
            updateOrAddParticipant(data.peerId, null, data.name, data.audioEnabled !== false, data.videoEnabled !== false);
            if (!callsRef.current[data.peerId]) connectAndCallPeer(data.peerId, data.name);
            break;
          case 'media-status-update':
            updateOrAddParticipant(senderPeerId, null, null, data.audioEnabled, data.videoEnabled);
            break;
          default: console.warn("Unknown signaling data type:", data.type);
        }
       }, [videos, displayName, callStartTime, updateOrAddParticipant, callPeer, connectAndCallPeer]); // Added callPeer, connectAndCallPeer

      const handleDisconnect = useCallback((pId, reason = "Unknown") => {
        setVideos(prev => {
            const newVideos = prev.filter(v => v.peerId !== pId);
            if (activeSpeakerId === pId) {
                const newActive = newVideos.find(v => v.isLocal)?.peerId || (newVideos.length > 0 ? newVideos[0]?.peerId : null);
                setActiveSpeakerId(newActive); // Set new active speaker *before* returning newVideos
            }
            return newVideos;
        });
        if (callsRef.current[pId]) { callsRef.current[pId].close(); delete callsRef.current[pId]; }
        if (connectionsRef.current[pId]) { connectionsRef.current[pId].close(); delete connectionsRef.current[pId]; }
       }, [activeSpeakerId]); // Removed videos from dependency here, setVideos handles it

      const joinRoom = useCallback(async () => {
        if (!peerRef.current || !peerId || !roomId.trim() || !displayName.trim()) {
            setStatus(!peerId ? "PeerID not ready." : "Room/Name ID required."); return;
        }
        setStatus('Getting media...');
        try {
          const stream = await navigator.mediaDevices.getUserMedia({ video: true, audio: { echoCancellation: true, noiseSuppression: true, autoGainControl: true }});
          localStreamRef.current = stream;
          stream.getVideoTracks().forEach(t => t.enabled = isVideoEnabled);
          stream.getAudioTracks().forEach(t => t.enabled = !isMuted);
          
          updateOrAddParticipant(peerId, stream, displayName, !isMuted, isVideoEnabled, true);
          setJoined(true);
          setActiveSpeakerId(peerId);
          
          if (roomId === peerId) { 
            setCallStartTime(Date.now()); 
            setStatus(`Hosting room. Share Room ID: ${peerId}`);
          } else { 
            setStatus('Joining room...');
            const conn = peerRef.current.connect(roomId, { metadata: { displayName, audioEnabled: !isMuted, videoEnabled: isVideoEnabled } });
            if (!conn) { setStatus("Failed to connect."); setJoined(false); return; }
            connectionsRef.current[roomId] = conn; 
            conn.on('open', () => {
              conn.send({ type: 'join-request', name: displayName, audioEnabled: !isMuted, videoEnabled: isVideoEnabled }); 
            });
            conn.on('data', data => handleSignalingData(data, conn));
            conn.on('close', () => { handleDisconnect(roomId, 'Host connection closed'); endCall(); }); // endCall is memoized
            conn.on('error', err => { handleDisconnect(roomId, `Host conn error: ${err.type}`); endCall(); });
          }
        } catch (err) { setStatus(`Media Error: ${err.message}. Check permissions.`); setJoined(false); }
       }, [peerId, roomId, displayName, isVideoEnabled, isMuted, updateOrAddParticipant, handleSignalingData, handleDisconnect, endCall]); // Added endCall

      const callPeer = useCallback((targetPeerId, targetName = '') => {
        if (!localStreamRef.current || callsRef.current[targetPeerId] || !peerRef.current || peerRef.current.disconnected) return;
        const remoteDisplayName = targetName || `Peer-${targetPeerId.substring(0,4)}`;
        const call = peerRef.current.call(targetPeerId, localStreamRef.current, { 
            metadata: { displayName, audioEnabled: !isMuted, videoEnabled: isVideoEnabled } 
        });
        if (!call) return;
        callsRef.current[targetPeerId] = call;
        updateOrAddParticipant(targetPeerId, null, remoteDisplayName, true, true); 
        call.on('stream', remoteStream => {
            const meta = call.metadata || {};
            updateOrAddParticipant(targetPeerId, remoteStream, meta.displayName || remoteDisplayName, meta.audioEnabled !== false, meta.videoEnabled !== false)
        });
        call.on('close', () => handleDisconnect(targetPeerId, `Call closed`));
        call.on('error', (err) => handleDisconnect(targetPeerId, `Call error: ${err.type}`));
       }, [displayName, isMuted, isVideoEnabled, updateOrAddParticipant, handleDisconnect]);

      const connectAndCallPeer = useCallback((targetPeerId, targetName = '') => {
        if (targetPeerId === peerId || (connectionsRef.current[targetPeerId] && callsRef.current[targetPeerId]) || !peerRef.current || peerRef.current.disconnected) return;
        const remoteDisplayName = targetName || `Peer-${targetPeerId.substring(0,4)}`;
        if (connectionsRef.current[targetPeerId]) {
            if (!callsRef.current[targetPeerId]) callPeer(targetPeerId, remoteDisplayName);
            return;
        }
        const conn = peerRef.current.connect(targetPeerId, { 
            metadata: { displayName, audioEnabled: !isMuted, videoEnabled: isVideoEnabled } 
        });
        if (!conn) return;
        connectionsRef.current[targetPeerId] = conn;
        conn.on('open', () => { if (!callsRef.current[targetPeerId]) callPeer(targetPeerId, remoteDisplayName); });
        conn.on('data', data => handleSignalingData(data, conn));
        conn.on('close', () => handleDisconnect(targetPeerId, `Data conn closed`));
        conn.on('error', err => handleDisconnect(targetPeerId, `Data conn error: ${err.type}`));
      }, [displayName, isMuted, isVideoEnabled, callPeer, handleSignalingData, handleDisconnect]);
      
      const endCall = useCallback(() => { 
        console.log("Ending call.");
        Object.values(callsRef.current).forEach(call => call.close());
        Object.values(connectionsRef.current).forEach(conn => conn.close());
        callsRef.current = {}; connectionsRef.current = {};
        localStreamRef.current?.getTracks().forEach(track => track.stop());
        localStreamRef.current = null;
        setVideos([]); setJoined(false); setActiveSpeakerId(null);
        setIsMuted(false); setIsVideoEnabled(true); 
        setCallStartTime(null); setElapsedTime(0);
        setStatus('Call ended. Ready to start/join another.');
       }, []);

      const toggleMute = useCallback(() => {
        if (!localStreamRef.current) return;
        const newMutedState = !isMuted;
        localStreamRef.current.getAudioTracks().forEach(track => { track.enabled = !newMutedState; });
        setIsMuted(newMutedState); // This will cause App to re-render
        updateOrAddParticipant(peerId, localStreamRef.current, displayName, !newMutedState, isVideoEnabled, true);
        broadcastMediaStatus();
       }, [isMuted, peerId, displayName, isVideoEnabled, updateOrAddParticipant, broadcastMediaStatus]);

      const toggleVideo = useCallback(() => {
        if (!localStreamRef.current) return;
        const newVideoEnabledState = !isVideoEnabled;
        localStreamRef.current.getVideoTracks().forEach(track => { track.enabled = newVideoEnabledState; });
        setIsVideoEnabled(newVideoEnabledState); // This will cause App to re-render
        updateOrAddParticipant(peerId, localStreamRef.current, displayName, !isMuted, newVideoEnabledState, true);
        broadcastMediaStatus();
       }, [isVideoEnabled, peerId, displayName, isMuted, updateOrAddParticipant, broadcastMediaStatus]);

      const formatTime = useCallback((totalSeconds) => {
        const hours = Math.floor(totalSeconds / 3600);
        const minutes = Math.floor((totalSeconds % 3600) / 60);
        const seconds = totalSeconds % 60;
        return `${hours > 0 ? String(hours).padStart(2, '0')+':' : ''}${String(minutes).padStart(2, '0')}:${String(seconds).padStart(2, '0')}`;
      }, []);
      
      const handleToggleLayout = useCallback(() => {
        setViewMode(prev => prev === 'gallery' ? 'speaker' : 'gallery');
      }, []);
      
      const handleSetActiveSpeaker = useCallback((id) => {
        setActiveSpeakerId(id);
      }, []);


      console.log("App rendering. Joined:", joined); // Debug App re-renders

      // --- Main App JSX ---
      return (
        <div className="w-full h-screen flex flex-col bg-gray-900">
          {!joined ? (
            <div className="flex-grow flex flex-col items-center justify-center p-4">
              <h1 className="text-4xl font-bold text-purple-400 mb-2">SyncLite Pro - V4.1</h1>
              <p className="text-xs text-gray-400 mb-6">Video Chat made Simple</p>
              <div className="bg-gray-800 p-6 sm:p-8 rounded-xl shadow-2xl w-full max-w-md space-y-5">
                <p className="text-center text-sm"><strong>Your Peer ID:</strong> <span className="text-green-400 break-all block mt-1">{peerId || 'Connecting...'}</span></p>
                <div><label htmlFor="displayNameInput" className="block text-xs font-medium text-gray-300 mb-1">Your Name</label><input id="displayNameInput" className="border-transparent p-3 w-full rounded-md bg-gray-700 text-white placeholder-gray-500 focus:ring-2 focus:ring-purple-500 focus:outline-none" placeholder="Enter your display name" value={displayName} onChange={e => setDisplayName(e.target.value)} disabled={!peerId} /></div>
                <div><label htmlFor="roomIdInput" className="block text-xs font-medium text-gray-300 mb-1">Room ID</label><input id="roomIdInput" className="border-transparent p-3 w-full rounded-md bg-gray-700 text-white placeholder-gray-500 focus:ring-2 focus:ring-purple-500 focus:outline-none" placeholder="Enter Room ID or your ID to host" value={roomId} onChange={e => setRoomId(e.target.value)} disabled={!peerId} /></div>
                <p className="text-center text-xs text-red-400 h-4">{status.startsWith("Ready") ? "" : status}</p>
                <button onClick={joinRoom} className="bg-purple-600 hover:bg-purple-700 text-white py-3 px-4 rounded-md w-full font-semibold disabled:opacity-50" disabled={!peerId || !roomId.trim() || !displayName.trim()}> {(roomId === peerId && peerId) ? 'Start & Host Chat' : 'Join Chat Room'} </button>
              </div>
            </div>
          ) : (
            <div className="flex-grow flex flex-col overflow-hidden w-full relative">
              <StatusBar currentTime={elapsedTime} userDisplayName={displayName} currentNetworkType={networkType} formatTimeFunc={formatTime} />
              <VideoLayout 
                videos={videos}
                viewMode={viewMode}
                activeSpeakerId={activeSpeakerId}
                isLocalVideoGloballyEnabled={isVideoEnabled} // Pass global state for local video
                isLocalAudioGloballyMuted={isMuted} // Pass global state for local audio
                onSetActiveSpeaker={handleSetActiveSpeaker}
                onSetViewMode={setViewMode} // Pass setViewMode directly if VideoLayout needs to change it (e.g. gallery click)
              />
              <div className="flex-shrink-0 bg-gray-800 p-3 sm:p-4 shadow-up w-full">
                <Controls 
                    isMuted={isMuted} 
                    isVideoEnabled={isVideoEnabled}
                    onToggleMute={toggleMute}
                    onToggleVideo={toggleVideo}
                    onToggleLayout={handleToggleLayout}
                    onEndCall={endCall}
                    videoCount={videos.filter(v => v.stream || v.isLocal).length}
                    currentViewMode={viewMode}
                />
              </div>
            </div>
          )}
        </div>
      );
    }
    ReactDOM.createRoot(document.getElementById('root')).render(<App />);
  </script>
</body>
</html>
