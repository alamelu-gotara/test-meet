<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no"/>
  <title>SyncLite Pro Video Chat - V4.7</title>
  <script src="https://cdn.tailwindcss.com"></script>
  <script src="https://unpkg.com/react@18/umd/react.development.js"></script>
  <script src="https://unpkg.com/react-dom@18/umd/react-dom.development.js"></script>
  <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>
  <script src="https://webrtc.github.io/adapter/adapter-latest.js"></script>
  <script src="https://unpkg.com/peerjs@1.5.2/dist/peerjs.min.js"></script>
  <style>
    body { -webkit-font-smoothing: antialiased; -moz-osx-font-smoothing: grayscale; }
    .no-scrollbar::-webkit-scrollbar { display: none; }
    .no-scrollbar { -ms-overflow-style: none; scrollbar-width: none; }
    .video-container { position: relative; background-color: #1a202c; overflow: hidden; border-radius: 0.375rem; width: 100%; height: 100%; }
    .participant-name {
      position: absolute; bottom: 6px; left: 6px; background-color: rgba(0, 0, 0, 0.75);
      color: white; font-size: 0.7rem; padding: 3px 8px; border-radius: 0.25rem;
      max-width: calc(100% - 12px); overflow: hidden; text-overflow: ellipsis; white-space: nowrap; z-index: 10;
    }
    .video-element { width: 100%; height: 100%; display: block; }
    .disabled-video-placeholder, .remote-media-off-placeholder {
      width: 100%; height: 100%; display: flex; flex-direction: column;
      align-items: center; justify-content: center; background-color: #2d3748;
      color: #a0aec0; font-size: 0.875rem; text-align: center; padding: 0.5rem;
    }
    .media-status-icon {
        position: absolute; top: 8px; right: 8px; background-color: rgba(0,0,0,0.6);
        border-radius: 0.375rem; padding: 4px; z-index: 15; display: flex; gap: 4px;
    }
     .local-media-status-icon {
        position: absolute; top: 8px; left: 8px; background-color: rgba(0,0,0,0.6);
        border-radius: 0.375rem; padding: 4px; z-index: 15; display: flex; gap: 4px;
    }
    .status-bar {
        position: absolute; top: 8px; left: 50%; transform: translateX(-50%);
        background-color: rgba(26, 32, 44, 0.85);
        backdrop-filter: blur(4px);
        color: white; padding: 6px 12px; 
        border-radius: 8px; font-size: 0.75rem; z-index: 30; /* Ensure above other elements */
        display: flex;
        align-items: center; gap: 10px; box-shadow: 0 2px 4px rgba(0,0,0,0.2);
    }
    .status-bar .timer { font-weight: 500; }
    .status-bar .network-info { display: flex; align-items: center; gap: 4px; }
    .copy-button {
        background-color: #4a5568; color: white; padding: 0.25rem 0.5rem; 
        font-size: 0.75rem; border-radius: 0.25rem; margin-left: 0.5rem; 
        transition: background-color 0.15s ease-in-out;
    }
    .copy-button:hover { background-color: #2d3748; }
    .copy-button:disabled { opacity: 0.5; cursor: not-allowed; }
    .pin-button {
        position: absolute; top: 8px; left: 8px; background-color: rgba(0,0,0,0.5); color: white;
        border-radius: 50%; padding: 6px; z-index: 16; cursor: pointer; opacity: 0; transition: opacity 0.2s;
    }
    .video-container-instance:hover .pin-button { opacity: 1; }
    .pinned-video { border: 2px solid #8B5CF6; /* Purple-500 */ }
  </style>
</head>
<body class="overflow-hidden"> {/* Prevent body scroll */}
  <div id="root" class="h-screen bg-gray-900 flex flex-col items-center text-white"></div>

  <script type="text/babel">
    const { useState, useRef, useEffect, useCallback, memo } = React;

    // --- Updated Icon Components ---
    // Material Design Style Icons for Mic/Video
    const MicOnIcon = memo(() => <svg xmlns="http://www.w3.org/2000/svg" className="h-5 w-5 sm:h-6 sm:w-6" viewBox="0 0 24 24" fill="currentColor"><path d="M0 0h24v24H0V0z" fill="none"/><path d="M12 14c1.66 0 2.99-1.34 2.99-3L15 5c0-1.66-1.34-3-3-3S9 3.34 9 5v6c0 1.66 1.34 3 3 3zm5.3-3c0 3-2.54 5.1-5.3 5.1S6.7 14 6.7 11H5c0 3.41 2.72 6.23 6 6.72V21h2v-3.28c3.28-.48 6-3.3 6-6.72h-1.7z"/></svg>);
    const MicOffIcon = memo(() => <svg xmlns="http://www.w3.org/2000/svg" className="h-5 w-5 sm:h-6 sm:w-6" viewBox="0 0 24 24" fill="currentColor"><path d="M0 0h24v24H0V0z" fill="none"/><path d="M19 11h-1.7c0 .74-.16 1.43-.43 2.05l1.23 1.23c.56-.98.9-2.09.9-3.28zm-4.02.17c0-.06 0-.11.02-.17V5c0-1.66-1.34-3-3-3S9 3.34 9 5v.18l5.98 5.99zM4.27 3L3 4.27l6.02 6.02V11c0 1.66 1.34 3 3 3 .22 0 .42-.03.62-.07L15.73 17l1.41-1.41L4.27 3zM12 14c.21 0 .4-.02.58-.05l-2.63-2.63V11c0 .55.45 1 1 1s1-.45 1-1v-.34l-2.95-2.95V5c0-.55.45-1 1-1s1 .45 1 1v3.18l-2.78-2.78C11.45 5.08 11.22 5 11 5c-.55 0-1 .45-1 1v.02L8.24 4.26C8.77 3.5 9.8 3 11 3c1.04 0 1.95.53 2.49 1.32L10 7.76V11c0 .4.13.76.33 1.06l-2.35 2.35C7.16 13.93 6.7 12.53 6.7 11H5c0 .97.26 1.86.71 2.64l1.79 1.79C8.99 16.48 10.43 17 12 17c.43 0 .85-.07 1.26-.2L17 20.73 18.27 19.46 9.29 10.48 4.27 5.46z"/></svg>); // More complex slash, ensures visibility
    const VideoOnIcon = memo(() => <svg xmlns="http://www.w3.org/2000/svg" className="h-5 w-5 sm:h-6 sm:w-6" viewBox="0 0 24 24" fill="currentColor"><path d="M0 0h24v24H0V0z" fill="none"/><path d="M17 10.5V7c0-.55-.45-1-1-1H4c-.55 0-1 .45-1 1v10c0 .55.45 1 1 1h12c.55 0 1-.45 1-1v-3.5l4 4v-11l-4 4z"/></svg>);
    const VideoOffIcon = memo(() => <svg xmlns="http://www.w3.org/2000/svg" className="h-5 w-5 sm:h-6 sm:w-6" viewBox="0 0 24 24" fill="currentColor"><path d="M0 0h24v24H0V0z" fill="none"/><path d="M21 6.5l-4 4V7c0-.55-.45-1-1-1H9.82L21 17.18V6.5zM3.27 2 2 3.27 4.73 6H4c-.55 0-1 .45-1 1v10c0 .55.45 1 1 1h12c.21 0 .39-.08.54-.18L19.73 21 21 19.73 3.27 2z"/></svg>);

    // Heroicons Solid
    const EndCallIcon = memo(() => <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="currentColor" className="w-5 h-5 sm:w-6 sm:h-6"><path fillRule="evenodd" d="M1.5 4.5a3 3 0 013-3h1.372c.86 0 1.61.586 1.819 1.42l1.105 4.423a1.875 1.875 0 01-.694 1.955l-1.293.97c-.135.101-.164.279-.088.401l2.71 4.273c.076.122.248.162.396.136l1.408-.704a1.875 1.875 0 012.164.047l4.272 3.457a3 3 0 01-4.242 4.242l-4.273-3.457a1.875 1.875 0 01-.047-2.164l.704-1.408a.25.25 0 00-.136-.396L5.337 8.551a1.875 1.875 0 01-1.955-.694L1.96 6.735A3 3 0 011.5 4.5zM14.624 19.32a1.5 1.5 0 00-2.121-2.121l2.121-2.121a1.5 1.5 0 002.121 2.121l-2.121 2.121zM18.868 15.076a1.5 1.5 0 00-2.121-2.121l2.121-2.121a1.5 1.5 0 002.121 2.121l-2.121 2.121z" clipRule="evenodd" /></svg>);
    const LayoutGalleryIcon = memo(() => <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="currentColor" className="w-5 h-5"><path fillRule="evenodd" d="M2.25 3.75A1.5 1.5 0 013.75 2.25h2.25a1.5 1.5 0 011.5 1.5v2.25a1.5 1.5 0 01-1.5 1.5H3.75a1.5 1.5 0 01-1.5-1.5V3.75zM2.25 9.75A1.5 1.5 0 013.75 8.25h2.25a1.5 1.5 0 011.5 1.5v2.25a1.5 1.5 0 01-1.5 1.5H3.75a1.5 1.5 0 01-1.5-1.5V9.75zM9.75 3.75A1.5 1.5 0 0111.25 2.25h2.25a1.5 1.5 0 011.5 1.5v2.25a1.5 1.5 0 01-1.5 1.5H11.25a1.5 1.5 0 01-1.5-1.5V3.75zM9.75 9.75A1.5 1.5 0 0111.25 8.25h2.25a1.5 1.5 0 011.5 1.5v2.25a1.5 1.5 0 01-1.5 1.5H11.25a1.5 1.5 0 01-1.5-1.5V9.75zM17.25 3.75A1.5 1.5 0 0118.75 2.25h2.25a1.5 1.5 0 011.5 1.5v2.25a1.5 1.5 0 01-1.5 1.5H18.75a1.5 1.5 0 01-1.5-1.5V3.75zM17.25 9.75A1.5 1.5 0 0118.75 8.25h2.25a1.5 1.5 0 011.5 1.5v2.25a1.5 1.5 0 01-1.5 1.5H18.75a1.5 1.5 0 01-1.5-1.5V9.75z" clipRule="evenodd" /></svg>); // Squares2X2Icon
    const LayoutSpeakerIcon = memo(() => <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="currentColor" className="w-5 h-5"><path fillRule="evenodd" d="M2.25 5.25A3.75 3.75 0 016 1.5h12A3.75 3.75 0 0121.75 5.25v10.5A3.75 3.75 0 0118 19.5H6A3.75 3.75 0 012.25 15.75V5.25zm1.5.75V15a2.25 2.25 0 002.25 2.25h12a2.25 2.25 0 002.25-2.25V6A2.25 2.25 0 0018 3.75H6A2.25 2.25 0 003.75 6zm17.25 9.75a.75.75 0 00-.75-.75H3a.75.75 0 000 1.5h17.25a.75.75 0 00.75-.75z" clipRule="evenodd" /></svg>); // ComputerDesktopIcon
    const LayoutsIcon = memo(() => <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="currentColor" className="w-5 h-5 sm:w-6 sm:h-6"><path fillRule="evenodd" d="M3 6.75A.75.75 0 013.75 6h16.5a.75.75 0 010 1.5H3.75A.75.75 0 013 6.75zM3 12a.75.75 0 01.75-.75h16.5a.75.75 0 010 1.5H3.75A.75.75 0 013 12zm0 5.25a.75.75 0 01.75-.75h16.5a.75.75 0 010 1.5H3.75a.75.75 0 01-.75-.75z" clipRule="evenodd" /></svg>); // Bars3Icon (Hamburger for menu)
    const ParticipantsIcon = memo(() => <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="currentColor" className="w-5 h-5 sm:w-6 sm:h-6"><path d="M4.5 6.375a4.125 4.125 0 118.25 0 4.125 4.125 0 01-8.25 0zM14.25 8.625a3.375 3.375 0 116.75 0 3.375 3.375 0 01-6.75 0zM1.5 19.125a7.125 7.125 0 0114.25 0v.003l-.001.119a.75.75 0 01-.363.63 13.067 13.067 0 01-6.761 1.873c-2.472 0-4.786-.684-6.76-1.873a.75.75 0 01-.364-.63l-.001-.122zM17.25 19.128l-.001.144a2.25 2.25 0 01-.233.96 10.088 10.088 0 005.06-1.104v-.003a5.625 5.625 0 00-4.826-4.498 29.994 29.994 0 00-2.779-.25A29.88 29.88 0 0012 15.75c-.665 0-1.316.042-1.957.124A5.625 5.625 0 005.12 20.75v.003a10.09 10.09 0 005.06 1.103 2.25 2.25 0 01-.232-.96l-.001-.144z" /></svg>); // UserGroupIcon
    const PinIcon = memo(({ sizeClass = "h-4 w-4"}) => <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="currentColor" className={sizeClass}><path fillRule="evenodd" d="M11.54 22.351l.07.04.028.016a.76.76 0 00.723 0l.028-.015.071-.041a16.975 16.975 0 001.144-.742 19.58 19.58 0 002.683-2.282c1.944-1.99 3.963-4.98 3.963-8.827a8.25 8.25 0 00-16.5 0c0 3.846 2.02 6.837 3.963 8.827a19.58 19.58 0 002.682 2.282 16.975 16.975 0 001.145.742zM12 13.5a3 3 0 100-6 3 3 0 000 6z" clipRule="evenodd" /></svg>); // MapPinIcon
    const PinnedIcon = memo(({ sizeClass = "h-4 w-4 text-purple-400" }) => <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="currentColor" className={sizeClass}><path fillRule="evenodd" d="M11.54 22.351l.07.04.028.016a.76.76 0 00.723 0l.028-.015.071-.041a16.975 16.975 0 001.144-.742 19.58 19.58 0 002.683-2.282c1.944-1.99 3.963-4.98 3.963-8.827a8.25 8.25 0 00-16.5 0c0 3.846 2.02 6.837 3.963 8.827a19.58 19.58 0 002.682 2.282 16.975 16.975 0 001.145.742zM12 13.5a3 3 0 100-6 3 3 0 000 6z" clipRule="evenodd" /></svg>);

    // --- Small Status Icons ---
    const VideoCamIcon = memo(() => <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 20 20" fill="currentColor" className="h-4 w-4"><path d="M3.75 3A1.75 1.75 0 002 4.75v10.5c0 .966.784 1.75 1.75 1.75h5.5A1.75 1.75 0 0011 15.25V4.75A1.75 1.75 0 009.25 3h-5.5zM16.042 3.885L13.75 5.64v8.72l2.292 1.754a.912.912 0 001.52-.66V4.546a.912.912 0 00-1.52-.66z" /></svg>);
    const VideoCamOffIcon = memo(() => <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 20 20" fill="currentColor" className="h-4 w-4"><path d="M7.25 10C7.25 8.20507 8.70507 6.75 10.5 6.75C12.2949 6.75 13.75 8.20507 13.75 10C13.75 11.7949 12.2949 13.25 10.5 13.25C8.70507 13.25 7.25 11.7949 7.25 10Z" /><path fillRule="evenodd" d="M2 4.75A1.75 1.75 0 013.75 3h5.5A1.75 1.75 0 0111 4.75v1.775C10.201 6.23 9.25 6 8.188 6A4.187 4.187 0 004 10.188C4 11.25 4.23 12.201 4.525 13H2V4.75zm14.042-.865L13.75 5.64v8.72l2.292 1.754a.912.912 0 001.52-.66V4.546a.912.912 0 00-1.52-.66zM1.964 2.022a.75.75 0 00-1.06 1.06L2.021 4.2l.028.028L17.978 18.036a.75.75 0 001.06-1.06L3.022 1.964l-.028-.028L1.964 2.022z" clipRule="evenodd" /></svg>);
    const MicStatusOffIcon = memo(() => <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 20 20" fill="currentColor" className="w-4 h-4"><path fillRule="evenodd" d="M9.474 2.168a.75.75 0 01.552-.01L19.5 6.022a.75.75 0 01.407.858l-3.5 9.5A.75.75 0 0115.5 17H4.5a.75.75 0 01-.859-1.12l3.5-9.5a.75.75 0 011.333-.212L9.474 2.168zm1.006-.962a2.25 2.25 0 00-1.658.33L.572 11.038a2.25 2.25 0 001.502 4.212H17.25a2.25 2.25 0 002.159-3.358L10.93 1.538a2.25 2.25 0 00-.45-.332zM3.929 19.512a.75.75 0 01-.139-1.49L15.732 6.27a.75.75 0 111.036 1.088L4.921 19.304a.75.75 0 01-.992.208z" clipRule="evenodd" /></svg>); // SpeakerXMarkIcon

    const ClockIcon = memo(() => <svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" strokeWidth={1.5} stroke="currentColor" className="w-4 h-4"><path strokeLinecap="round" strokeLinejoin="round" d="M12 6v6h4.5m4.5 0a9 9 0 11-18 0 9 9 0 0118 0z" /></svg>);
    const WifiIcon = memo(() => <svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" strokeWidth={1.5} stroke="currentColor" className="w-4 h-4"><path strokeLinecap="round" strokeLinejoin="round" d="M8.288 16.034A7.5 7.5 0 0112 15.75a7.5 7.5 0 013.712.284M11.25 18.75a1.5 1.5 0 11-3 0 1.5 1.5 0 013 0zm6-8.25a1.5 1.5 0 11-3 0 1.5 1.5 0 013 0zm-6 0a1.5 1.5 0 11-3 0 1.5 1.5 0 013 0zm6 4.492A12.003 12.003 0 0012 10.5a12.003 12.003 0 00-7.492 2.992" /></svg>);
    const SignalIcon = memo(() => <svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" strokeWidth={1.5} stroke="currentColor" className="w-4 h-4"><path strokeLinecap="round" strokeLinejoin="round" d="M2.25 13.5h3.86a2.25 2.25 0 012.25 2.25v3.75a2.25 2.25 0 01-2.25 2.25h-1.5a2.25 2.25 0 01-2.25-2.25v-3.75m11.359.016A2.25 2.25 0 0015.75 15.75v3.75a2.25 2.25 0 002.25 2.25h1.5a2.25 2.25 0 002.25-2.25v-3.75a2.25 2.25 0 00-2.25-2.25h-3.861m-3.478-.001A2.25 2.25 0 008.25 15.75v3.75a2.25 2.25 0 002.25 2.25h1.5a2.25 2.25 0 002.25-2.25v-3.75a2.25 2.25 0 00-2.25-2.25h-3.861" /></svg>); 
    const CopyIcon = memo(() => <svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" strokeWidth={1.5} stroke="currentColor" className="w-4 h-4 inline-block"><path strokeLinecap="round" strokeLinejoin="round" d="M15.75 17.25v3.375c0 .621-.504 1.125-1.125 1.125h-9.75a1.125 1.125 0 01-1.125-1.125V7.875c0-.621.504-1.125 1.125-1.125H6.75a9.06 9.06 0 011.5.124m7.5 10.376h3.375c.621 0 1.125-.504 1.125-1.125V11.25c0-4.46-3.243-8.161-7.5-8.876a9.06 9.06 0 00-1.5-.124H9.375c-.621 0-1.125.504-1.125 1.125T9.375 4.5h1.875c1.863 0 3.427 1.017 4.125 2.572V17.25z" /></svg>);

    const VideoPlaceholder = memo(({ text }) => ( <div className="disabled-video-placeholder"><VideoCamOffIcon /> <span className="mt-2">{text}</span></div>));
    const RemoteMediaOffPlaceholder = memo(({ text, isAudioOff, isVideoOff }) => (
      <div className="remote-media-off-placeholder">
          {isVideoOff && <VideoCamOffIcon />}
          {isAudioOff && !isVideoOff && <MicStatusOffIcon />}
          <span className="mt-2 text-xs">{text}</span>
      </div>));
    
    const VideoPlayer = memo(({ videoData, isLocalVideoGloballyEnabled, isLocalAudioGloballyMuted, localStream, onTogglePin, isPinned }) => { 
      const { peerId: videoPeerId, stream: remoteStream, isLocal, name, audioEnabled, videoEnabled: participantVideoEnabled } = videoData;
      const videoRef = useRef(null);
      const currentStream = isLocal ? localStream : remoteStream;

      useEffect(() => { 
          if (videoRef.current) {
              if (isLocal) {
                  if (isLocalVideoGloballyEnabled && currentStream) { videoRef.current.srcObject = currentStream; } 
                  else { videoRef.current.srcObject = null; }
              } else { 
                  if (participantVideoEnabled && currentStream) { videoRef.current.srcObject = currentStream; } 
                  else { videoRef.current.srcObject = null; }
              }
          }
      }, [currentStream, isLocal, isLocalVideoGloballyEnabled, participantVideoEnabled]); 

      if (isLocal && !isLocalVideoGloballyEnabled) { return <VideoPlaceholder text="Your camera is off" />; }
      if (!isLocal && !participantVideoEnabled) { return <RemoteMediaOffPlaceholder text={`${name}'s camera is off`} isVideoOff={true} isAudioOff={!audioEnabled} />; }
      if (!currentStream && ((isLocal && isLocalVideoGloballyEnabled) || (!isLocal && participantVideoEnabled))) { return <RemoteMediaOffPlaceholder text={`${name} (Connecting...)`} isVideoOff={!participantVideoEnabled} isAudioOff={!audioEnabled}/>; }
      if (!currentStream) {  return <RemoteMediaOffPlaceholder text={`${name} (Offline)`} isVideoOff={true} isAudioOff={true}/>; }

      return (
        <div className={`w-full h-full relative video-container-instance ${isPinned ? 'pinned-video' : ''}`} data-peer-id={videoPeerId}>
          <video ref={videoRef} autoPlay playsInline muted={isLocal} className="video-element object-cover" />
          {name && <div className="participant-name">{name}</div>}
          {!isLocal && (<button onClick={() => onTogglePin(videoPeerId)} title={isPinned ? "Unpin User" : "Pin User"} className="pin-button"> {isPinned ? <PinnedIcon sizeClass="h-5 w-5 text-purple-400" /> : <PinIcon sizeClass="h-5 w-5" />} </button> )}
          {!isLocal && (!audioEnabled || !participantVideoEnabled) && ( <div className="media-status-icon"> {!audioEnabled && <MicStatusOffIcon />} {!participantVideoEnabled && <VideoCamOffIcon/>} </div> )}
          {isLocal && isLocalAudioGloballyMuted && isLocalVideoGloballyEnabled && ( <div className="local-media-status-icon"> <MicStatusOffIcon /> </div> )}
          {isLocal && !isLocalVideoGloballyEnabled && isLocalAudioGloballyMuted && ( <div className="local-media-status-icon"> <MicStatusOffIcon /> <VideoCamOffIcon /> </div> )}
        </div>);
    }, (prevProps, nextProps) => { 
        const pvd = prevProps.videoData; const nvd = nextProps.videoData;
        return prevProps.localStream === nextProps.localStream &&
               pvd.stream === nvd.stream && pvd.name === nvd.name &&
               pvd.audioEnabled === nvd.audioEnabled && pvd.videoEnabled === nvd.videoEnabled &&
               pvd.isLocal === nvd.isLocal && pvd.peerId === nvd.peerId &&
               prevProps.isLocalVideoGloballyEnabled === nextProps.isLocalVideoGloballyEnabled &&
               prevProps.isLocalAudioGloballyMuted === nextProps.isLocalAudioGloballyMuted &&
               prevProps.isPinned === nextProps.isPinned; 
    });

    const ControlButton = memo(({ title, onClick, children, active = false, activeColor = "bg-red-500", defaultColor = "bg-gray-600 hover:bg-gray-500", className = "" }) => ( <button title={title} onClick={onClick} className={`p-2.5 sm:p-3 rounded-full text-white transition-colors duration-150 ease-in-out ${active ? activeColor : defaultColor} focus:outline-none focus:ring-2 focus:ring-purple-500 focus:ring-opacity-50 ${className}`}>{children}</button>));
    
    const LayoutMenu = memo(({ onSetViewMode, currentViewMode, closeMenu }) => (
        <div className="absolute bottom-full mb-2 w-40 bg-gray-700 rounded-md shadow-lg overflow-hidden z-30">
            <button onClick={() => { onSetViewMode('speaker'); closeMenu(); }} className={`flex items-center gap-2 w-full text-left px-3 py-2 text-sm ${currentViewMode === 'speaker' ? 'bg-purple-600' : 'hover:bg-gray-600'}`}> <LayoutSpeakerIcon /> Speaker</button>
            <button onClick={() => { onSetViewMode('gallery'); closeMenu(); }} className={`flex items-center gap-2 w-full text-left px-3 py-2 text-sm ${currentViewMode === 'gallery' ? 'bg-purple-600' : 'hover:bg-gray-600'}`}> <LayoutGalleryIcon /> Gallery</button>
        </div>
    ));

    const Controls = memo(({ isMuted, isVideoEnabled, onToggleMute, onToggleVideo, onToggleLayoutMenu, onEndCall, onToggleFilmstrip, isFilmstripVisible, videoCount, currentViewMode }) => (
        <div className="flex justify-center items-center space-x-2 sm:space-x-3 relative">
            <ControlButton title={isMuted ? "Unmute" : "Mute"} onClick={onToggleMute} active={isMuted}>{isMuted ? <MicOffIcon/> : <MicOnIcon/>}</ControlButton>
            <ControlButton title={isVideoEnabled ? "Cam Off" : "Cam On"} onClick={onToggleVideo} active={!isVideoEnabled}>{isVideoEnabled ? <VideoOnIcon/> : <VideoOffIcon/>}</ControlButton>
            {videoCount > 0 && <ControlButton title="Layouts" onClick={onToggleLayoutMenu}><LayoutsIcon/></ControlButton>}
            {videoCount > 0 && currentViewMode === 'speaker' && <ControlButton title={isFilmstripVisible ? "Hide Participants" : "Show Participants"} onClick={onToggleFilmstrip} active={isFilmstripVisible} defaultColor="bg-gray-600 hover:bg-gray-500"><ParticipantsIcon/></ControlButton>}
            <ControlButton title="End Call" onClick={onEndCall} defaultColor="bg-red-600 hover:bg-red-700"><EndCallIcon/></ControlButton>
        </div>));

    const StatusBar = memo(({currentTime, userDisplayName, currentNetworkType, formatTimeFunc}) => (
        <div className="status-bar">
            <ClockIcon /> <span className="timer">{formatTimeFunc(currentTime)}</span> <span className="mx-1 opacity-50">|</span>
            <span className="truncate max-w-[100px] sm:max-w-[150px]" title={userDisplayName}>{userDisplayName}</span>
            {(currentNetworkType && currentNetworkType !== 'N/A' && currentNetworkType !== 'loading...') && (<> <span className="mx-1 opacity-50">|</span> <span className="network-info">{currentNetworkType === 'cellular' ? <SignalIcon /> : <WifiIcon />}<span className="capitalize">{currentNetworkType}</span></span> </>)}
        </div>));

    const VideoLayout = memo(({ videos, viewMode, activeSpeakerId, isLocalVideoGloballyEnabled, isLocalAudioGloballyMuted, localStreamForPlayer, onSetActiveSpeaker, onSetViewMode, isFilmstripVisible, pinnedPeerId, onTogglePin }) => {
        const activeSpeakerData = videos.find(v => v.peerId === activeSpeakerId);
        const filmstripVideosData = videos.filter(v => v.peerId !== activeSpeakerId && (v.stream || v.isLocal)); 
        const galleryGridVideosData = videos.filter(v => v.stream || v.isLocal); 
        const galleryCols = galleryGridVideosData.length <= 1 ? 1 : (galleryGridVideosData.length <= 4 ? 2 : (galleryGridVideosData.length <= 9 ? 3 : 4));
        
        const videoPlayerProps = (video) => ({
            videoData: video, isLocalVideoGloballyEnabled, isLocalAudioGloballyMuted, 
            localStream: localStreamForPlayer, onTogglePin, isPinned: video.peerId === pinnedPeerId
        });

        return (
            <div className="flex-grow flex flex-col bg-black p-1 sm:p-2 min-h-0"> 
            {viewMode === 'speaker' ? (
              <div className="flex flex-col flex-grow h-full space-y-1 sm:space-y-2 min-h-0">
                <div className="flex-grow video-container min-h-0">
                  {activeSpeakerData ? (<VideoPlayer {...videoPlayerProps(activeSpeakerData)} />
                  ) : <VideoPlaceholder text={videos.length > 0 ? "Select participant" : "Waiting..."} />}
                </div>
                {isFilmstripVisible && filmstripVideosData.length > 0 && (
                   <div className="flex-shrink-0 h-24 sm:h-32 bg-gray-800/50 p-1 sm:p-2 flex space-x-1 sm:space-x-2 overflow-x-auto no-scrollbar items-center rounded-md">
                    {filmstripVideosData.map(video => (<div key={video.peerId} className={`video-container w-28 sm:w-40 h-full cursor-pointer border-2 border-transparent hover:border-purple-500 ${video.peerId === pinnedPeerId ? 'pinned-video' : ''}`} onClick={() => onSetActiveSpeaker(video.peerId)} tabIndex="0">
                        <VideoPlayer {...videoPlayerProps(video)} />
                      </div>))}</div>)}
              </div>
            ) : ( 
              <div className={`flex-grow p-1 sm:p-2 grid gap-1 sm:gap-2 overflow-y-auto grid-cols-${galleryCols} min-h-0`}>
                {galleryGridVideosData.map(video => (<div key={video.peerId} className={`video-container aspect-video ${video.peerId === pinnedPeerId ? 'pinned-video' : ''}`} onClick={() => { onSetActiveSpeaker(video.peerId); onSetViewMode('speaker');}} tabIndex="0">
                    <VideoPlayer {...videoPlayerProps(video)} />
                  </div>))}
                 {galleryGridVideosData.length === 0 && <div className="disabled-video-placeholder col-span-full row-span-full"><VideoPlaceholder text="No one here" /></div>}
              </div>)}</div>);
    });

    // ... (Rest of the App component and its functions remain the same as V4.6)
    // Ensure all useCallback dependencies are correct, especially for functions using refs.
    // The core logic for WebRTC, PeerJS, state management, etc., is not changed in this specific icon update.

    function App() {
      const [peerId, setPeerId] = useState('');
      const [roomId, setRoomId] = useState('');
      const [displayName, setDisplayName] = useState(''); 
      const [status, setStatus] = useState('Initializing Peer Connection...');
      const [videos, setVideos] = useState([]); 
      const [joined, setJoined] = useState(false);
      const [isMuted, setIsMuted] = useState(false);
      const [isVideoEnabled, setIsVideoEnabled] = useState(true);
      const [viewMode, setViewMode] = useState('speaker'); 
      const [activeSpeakerId, setActiveSpeakerId] = useState(null); 
      const [callStartTime, setCallStartTime] = useState(null);
      const [elapsedTime, setElapsedTime] = useState(0); 
      const [networkType, setNetworkType] = useState('loading...');
      const [nameEntered, setNameEntered] = useState(false);
      const [copied, setCopied] = useState(false);
      // New UI states
      const [controlsVisible, setControlsVisible] = useState(true);
      const [showLayoutMenu, setShowLayoutMenu] = useState(false);
      const [isFilmstripVisible, setIsFilmstripVisible] = useState(true);
      const [pinnedPeerId, setPinnedPeerId] = useState(null);


      const peerRef = useRef(null);
      const connectionsRef = useRef({});
      const callsRef = useRef({});
      const localStreamRef = useRef(null);
      const timerIntervalRef = useRef(null);
      const controlsTimeoutRef = useRef(null);
      const appContainerRef = useRef(null); 

      const displayNameRef = useRef(displayName);
      const peerIdRef = useRef(peerId);
      const isMutedRef = useRef(isMuted);
      const isVideoEnabledRef = useRef(isVideoEnabled);

      useEffect(() => { displayNameRef.current = displayName; }, [displayName]);
      useEffect(() => { peerIdRef.current = peerId; }, [peerId]);
      useEffect(() => { isMutedRef.current = isMuted; }, [isMuted]);
      useEffect(() => { isVideoEnabledRef.current = isVideoEnabled; }, [isVideoEnabled]);

      const showControlsTemporarily = useCallback(() => {
        setControlsVisible(true);
        clearTimeout(controlsTimeoutRef.current);
        controlsTimeoutRef.current = setTimeout(() => {
            if (!showLayoutMenu) { 
                 setControlsVisible(false);
            }
        }, 3000);
      }, [showLayoutMenu]);

      useEffect(() => {
        const appDiv = appContainerRef.current;
        if (joined && appDiv) {
            appDiv.addEventListener('mousemove', showControlsTemporarily);
            showControlsTemporarily(); 
        }
        return () => {
            if (appDiv) appDiv.removeEventListener('mousemove', showControlsTemporarily);
            clearTimeout(controlsTimeoutRef.current);
        };
      }, [joined, showControlsTemporarily]);

      useEffect(() => { 
        if (peerRef.current) peerRef.current.destroy();
        const newPeerInstance = new Peer(undefined, { debug: 2 });
        peerRef.current = newPeerInstance;
        newPeerInstance.on('open', (id) => { setPeerId(id); peerIdRef.current = id; setStatus('Ready. Enter Name.'); }); 
        newPeerInstance.on('connection', (conn) => {
          if (!peerRef.current || peerRef.current.disconnected || peerRef.current !== newPeerInstance) return;
          const remotePeerId = conn.peer; const remoteMeta = conn.metadata || {};
          connectionsRef.current[remotePeerId] = conn;
          const initialName = remoteMeta.displayName || `Peer-${remotePeerId.substring(0,4)}`;
          updateOrAddParticipant(remotePeerId, undefined, initialName, remoteMeta.audioEnabled !== false, remoteMeta.videoEnabled !== false);
          conn.on('data', data => handleSignalingData(data, conn));
          conn.on('close', () => handleDisconnect(remotePeerId, 'Data conn closed'));
          conn.on('error', err => handleDisconnect(remotePeerId, `Data conn error: ${err.type}`));
        });
        newPeerInstance.on('call', (call) => {
          if (!peerRef.current || peerRef.current.disconnected || peerRef.current !== newPeerInstance) return;
          const remotePeerId = call.peer; const remoteMeta = call.metadata || {};
          const currentDisplayNameForMeta = displayNameRef.current.trim() || `User-${peerIdRef.current ? peerIdRef.current.substring(0,4) : 'anon'}`;
          if (localStreamRef.current) call.answer(localStreamRef.current, { metadata: { displayName: currentDisplayNameForMeta, audioEnabled: !isMutedRef.current, videoEnabled: isVideoEnabledRef.current } });
          else return; 
          callsRef.current[remotePeerId] = call;
          const initialName = remoteMeta.displayName || `Peer-${remotePeerId.substring(0,4)}`;
          updateOrAddParticipant(remotePeerId, undefined, initialName, remoteMeta.audioEnabled !== false, remoteMeta.videoEnabled !== false);
          call.on('stream', remoteStream => {
            const currentMeta = call.metadata || {};
            updateOrAddParticipant(remotePeerId, remoteStream, currentMeta.displayName || initialName, currentMeta.audioEnabled !== false, currentMeta.videoEnabled !== false);
          });
          call.on('close', () => handleDisconnect(remotePeerId, 'Call closed'));
          call.on('error', (err) => handleDisconnect(remotePeerId, `Call error: ${err.type}`));
        });
        newPeerInstance.on('disconnected', () => { if (peerRef.current === newPeerInstance && !peerRef.current.destroyed) setStatus('Signaling server disconnected. Reconnecting...'); });
        newPeerInstance.on('close', () => console.log('PeerJS: "close" event (peer destroyed).'));
        newPeerInstance.on('error', (err) => { console.error('PeerJS Error:', err); if (peerRef.current === newPeerInstance && !peerRef.current.destroyed) setStatus(`PeerJS Error: ${err.type}`);});
        return () => { 
            if(newPeerInstance) newPeerInstance.destroy(); if (peerRef.current === newPeerInstance) peerRef.current = null; 
            Object.values(callsRef.current).forEach(c => c.close()); Object.values(connectionsRef.current).forEach(c => c.close());
            callsRef.current = {}; connectionsRef.current = {};
            localStreamRef.current?.getTracks().forEach(track => track.stop()); localStreamRef.current = null;
            clearInterval(timerIntervalRef.current); clearTimeout(controlsTimeoutRef.current);
        };
      }, []); 

      useEffect(() => { 
        if (joined && callStartTime) { timerIntervalRef.current = setInterval(() => { setElapsedTime(prevTime => prevTime + 1); }, 1000);
        } else { clearInterval(timerIntervalRef.current); setElapsedTime(0); }
        return () => clearInterval(timerIntervalRef.current);
      }, [joined, callStartTime]);

      useEffect(() => { 
        const updateNetworkInfo = () => { setNetworkType(navigator.connection ? (navigator.connection.effectiveType || navigator.connection.type || 'N/A') : 'N/A'); };
        updateNetworkInfo(); if (navigator.connection) navigator.connection.addEventListener('change', updateNetworkInfo);
        return () => { if (navigator.connection) navigator.connection.removeEventListener('change', updateNetworkInfo);};
      }, []);
      
      const updateOrAddParticipant = useCallback((pId, stream = undefined, name = null, audioEnabled = true, videoEnabled = true, isLocal = false) => {
        setVideos(prevVideos => {
          const existingVidIndex = prevVideos.findIndex(v => v.peerId === pId);
          const currentLocalDisplayName = displayNameRef.current.trim() || (peerIdRef.current ? `User-${peerIdRef.current.substring(0,4)}` : "You");
          let finalName = isLocal ? currentLocalDisplayName : (name || (existingVidIndex !== -1 ? prevVideos[existingVidIndex].name : `Peer-${pId.substring(0,4)}`));
          
          if (existingVidIndex !== -1) {
            const currentVid = prevVideos[existingVidIndex];
            if ( (stream === undefined || currentVid.stream === stream) && currentVid.name === finalName && 
                 currentVid.audioEnabled === audioEnabled && currentVid.videoEnabled === videoEnabled &&
                 currentVid.isLocal === isLocal) { return prevVideos; }
            const updatedVid = { ...currentVid, name: finalName, audioEnabled, videoEnabled, isLocal };
            if (stream !== undefined) updatedVid.stream = stream;
            const newVideos = [...prevVideos]; newVideos[existingVidIndex] = updatedVid; return newVideos;
          } else {
            return [...prevVideos, { peerId: pId, stream: stream === undefined ? null : stream, name: finalName, isLocal, audioEnabled, videoEnabled }];
          }
        });
         if (isLocal && !activeSpeakerId && stream !== undefined && stream !== null) setActiveSpeakerId(pId);
      }, [activeSpeakerId]); 
      
      const broadcastMediaStatus = useCallback(() => {
        if (!joined || !localStreamRef.current) return; 
        const currentDisplayName = displayNameRef.current.trim() || `User-${peerIdRef.current ? peerIdRef.current.substring(0, 4) : 'anon'}`;
        const payload = { type: 'media-status-update', audioEnabled: !isMutedRef.current, videoEnabled: isVideoEnabledRef.current, name: currentDisplayName };
        Object.values(connectionsRef.current).forEach(conn => { if (conn.open) conn.send(payload); });
      }, [joined]); 

      useEffect(() => { broadcastMediaStatus(); }, [isMuted, isVideoEnabled, joined, broadcastMediaStatus]);


      const handleSignalingData = useCallback((data, conn) => { 
        const senderPeerId = conn.peer; const senderMeta = conn.metadata || {};
        const senderDisplayName = data.name || senderMeta.displayName || `Peer-${senderPeerId.substring(0,4)}`;
        switch (data.type) {
          case 'join-request':
            updateOrAddParticipant(senderPeerId, undefined, senderDisplayName, data.audioEnabled !== false, data.videoEnabled !== false);
            const currentPeers = videos.filter(v => v.peerId !== peerIdRef.current).map(v => ({ peerId: v.peerId, name: v.name, audioEnabled: v.audioEnabled, videoEnabled: v.videoEnabled }));
            const hostDisplayName = displayNameRef.current.trim() || `Host-${peerIdRef.current ? peerIdRef.current.substring(0,4) : 'anon'}`;
            conn.send({ type: 'room-info', peers: currentPeers, hostName: hostDisplayName, startTime: callStartTime || Date.now() });
            Object.values(connectionsRef.current).forEach(c => { if (c.peer !== senderPeerId && c.open) c.send({ type: 'new-peer', peerId: senderPeerId, name: senderDisplayName, audioEnabled: data.audioEnabled !== false, videoEnabled: data.videoEnabled !== false }); });
            if (localStreamRef.current && !callsRef.current[senderPeerId]) callPeer(senderPeerId, senderDisplayName);
            break;
          case 'room-info': 
            if (data.startTime && !callStartTime) setCallStartTime(data.startTime);
            data.peers.forEach(pInfo => {
              updateOrAddParticipant(pInfo.peerId, undefined, pInfo.name, pInfo.audioEnabled !== false, pInfo.videoEnabled !== false);
              if (!callsRef.current[pInfo.peerId]) connectAndCallPeer(pInfo.peerId, pInfo.name);
            });
            updateOrAddParticipant(senderPeerId, undefined, data.hostName, senderMeta.audioEnabled !== false, senderMeta.videoEnabled !== false);
            break;
          case 'new-peer': 
            updateOrAddParticipant(data.peerId, undefined, data.name, data.audioEnabled !== false, data.videoEnabled !== false);
            if (!callsRef.current[data.peerId]) connectAndCallPeer(data.peerId, data.name);
            break;
          case 'media-status-update': 
            console.log(`[${peerIdRef.current === roomId ? 'Host' : 'Participant'}] Received media-status-update from ${senderPeerId}: audio=${data.audioEnabled}, video=${data.videoEnabled}, name=${data.name}`);
            updateOrAddParticipant(senderPeerId, undefined, data.name, data.audioEnabled, data.videoEnabled); 
            break;
          default: console.warn("Unknown signaling data type:", data.type);
        }
       }, [videos, callStartTime, updateOrAddParticipant, callPeer, connectAndCallPeer, roomId]); 

      const handleDisconnect = useCallback((pId, reason = "Unknown") => {
        console.log(`Handling disconnect for ${pId}, reason: ${reason}`);
        setVideos(prev => { 
            const newVideos = prev.filter(v => v.peerId !== pId); 
            if (activeSpeakerId === pId) { 
                const newActive = newVideos.find(v => v.isLocal)?.peerId || (newVideos.length > 0 ? newVideos[0]?.peerId : null); 
                setActiveSpeakerId(newActive); 
            } 
            if (pinnedPeerId === pId) setPinnedPeerId(null); 
            return newVideos; 
        });
        if (callsRef.current[pId]) { callsRef.current[pId].close(); delete callsRef.current[pId]; }
        if (connectionsRef.current[pId]) { connectionsRef.current[pId].close(); delete connectionsRef.current[pId]; }
       }, [activeSpeakerId, pinnedPeerId]);
      
      const joinRoom = useCallback(async () => {
        const currentDisplayName = displayNameRef.current.trim() || `User-${peerIdRef.current ? peerIdRef.current.substring(0,4) : 'anon'}`;
        if (!peerRef.current || !peerIdRef.current || !roomId.trim() || !currentDisplayName) { 
            setStatus(!peerIdRef.current ? "PeerID not ready." : "Name & Room ID required."); return; 
        }
        setStatus('Getting media...');
        try {
          const stream = await navigator.mediaDevices.getUserMedia({ video: true, audio: { echoCancellation: true, noiseSuppression: true, autoGainControl: true }});
          localStreamRef.current = stream; 
          stream.getVideoTracks().forEach(t => t.enabled = isVideoEnabledRef.current); 
          stream.getAudioTracks().forEach(t => t.enabled = !isMutedRef.current);
          
          updateOrAddParticipant(peerIdRef.current, stream, currentDisplayName, !isMutedRef.current, isVideoEnabledRef.current, true);
          setJoined(true); setActiveSpeakerId(peerIdRef.current); 

          if (roomId === peerIdRef.current) { 
            setCallStartTime(Date.now()); setStatus(`Hosting room: ${roomId}`); 
          } else { 
            setStatus(`Joining room: ${roomId}...`);
            const conn = peerRef.current.connect(roomId, { metadata: { displayName: currentDisplayName, audioEnabled: !isMutedRef.current, videoEnabled: isVideoEnabledRef.current }, reliable: true });
            if (!conn) { setStatus("Failed to connect to host."); setJoined(false); return; }
            connectionsRef.current[roomId] = conn; 
            conn.on('open', () => { conn.send({ type: 'join-request', name: currentDisplayName, audioEnabled: !isMutedRef.current, videoEnabled: isVideoEnabledRef.current }); });
            conn.on('data', data => handleSignalingData(data, conn));
            conn.on('close', () => { handleDisconnect(roomId, 'Host closed connection'); setStatus('Host left the room.'); endCall(false); });
            conn.on('error', err => { handleDisconnect(roomId, `Host connection error: ${err.type}`); setStatus(`Error with host: ${err.type}`); endCall(false); });
          }
        } catch (err) { setStatus(`Media Error: ${err.message}. Check permissions.`); setJoined(false); console.error("getUserMedia error:", err); }
       }, [roomId, updateOrAddParticipant, handleSignalingData, handleDisconnect, endCall]); 

      const callPeer = useCallback((targetPeerId, targetName = '') => {
        if (!localStreamRef.current || callsRef.current[targetPeerId] || !peerRef.current || peerRef.current.disconnected || targetPeerId === peerIdRef.current) return;
        const remoteDisplayName = targetName || `Peer-${targetPeerId.substring(0,4)}`;
        const currentDisplayName = displayNameRef.current.trim() || `User-${peerIdRef.current ? peerIdRef.current.substring(0,4) : 'anon'}`;
        
        const call = peerRef.current.call(targetPeerId, localStreamRef.current, { metadata: { displayName: currentDisplayName, audioEnabled: !isMutedRef.current, videoEnabled: isVideoEnabledRef.current } });
        if (!call) { console.error("Failed to initiate call to", targetPeerId); return; }
        callsRef.current[targetPeerId] = call;
        updateOrAddParticipant(targetPeerId, undefined, remoteDisplayName, true, true); 
        
        call.on('stream', remoteStream => { 
            const meta = call.metadata || {}; 
            updateOrAddParticipant(targetPeerId, remoteStream, meta.displayName || remoteDisplayName, meta.audioEnabled !== false, meta.videoEnabled !== false);
        });
        call.on('close', () => handleDisconnect(targetPeerId, `Call with ${remoteDisplayName} closed`)); 
        call.on('error', (err) => handleDisconnect(targetPeerId, `Call with ${remoteDisplayName} error: ${err.type}`));
       }, [updateOrAddParticipant, handleDisconnect]);

      const connectAndCallPeer = useCallback((targetPeerId, targetName = '') => {
        if (targetPeerId === peerIdRef.current || !peerRef.current || peerRef.current.disconnected) return;
        if (connectionsRef.current[targetPeerId] && callsRef.current[targetPeerId]) return;

        const remoteDisplayName = targetName || `Peer-${targetPeerId.substring(0,4)}`;
        const currentDisplayName = displayNameRef.current.trim() || `User-${peerIdRef.current ? peerIdRef.current.substring(0,4) : 'anon'}`;

        if (connectionsRef.current[targetPeerId]) { 
            if (!callsRef.current[targetPeerId] && localStreamRef.current) callPeer(targetPeerId, remoteDisplayName); 
            return; 
        }
        const conn = peerRef.current.connect(targetPeerId, { metadata: { displayName: currentDisplayName, audioEnabled: !isMutedRef.current, videoEnabled: isVideoEnabledRef.current }, reliable: true });
        if (!conn) { console.error("Failed to connect to", targetPeerId); return; }
        connectionsRef.current[targetPeerId] = conn;
        conn.on('open', () => { 
            updateOrAddParticipant(targetPeerId, undefined, remoteDisplayName, true, true); 
            if (!callsRef.current[targetPeerId] && localStreamRef.current) callPeer(targetPeerId, remoteDisplayName); 
        });
        conn.on('data', data => handleSignalingData(data, conn));
        conn.on('close', () => handleDisconnect(targetPeerId, `Data connection with ${remoteDisplayName} closed`)); 
        conn.on('error', err => handleDisconnect(targetPeerId, `Data connection with ${remoteDisplayName} error: ${err.type}`));
      }, [callPeer, handleSignalingData, handleDisconnect, updateOrAddParticipant]);
      
      const endCall = useCallback((reInitPeer = true) => { 
        Object.values(callsRef.current).forEach(call => call.close()); 
        Object.values(connectionsRef.current).forEach(conn => conn.close());
        callsRef.current = {}; connectionsRef.current = {};
        localStreamRef.current?.getTracks().forEach(track => track.stop()); 
        localStreamRef.current = null;
        setVideos([]); setJoined(false); setActiveSpeakerId(null); setPinnedPeerId(null);
        setIsMuted(false); isMutedRef.current = false;
        setIsVideoEnabled(true); isVideoEnabledRef.current = true;
        setCallStartTime(null); setElapsedTime(0); 
        if (reInitPeer) { setStatus('Call ended. Ready to start/join another.'); } 
        else { setStatus('Disconnected from room.'); }
        setShowLayoutMenu(false); setIsFilmstripVisible(true);
       }, []); 

      const toggleMute = useCallback(() => {
        if (!localStreamRef.current) return; 
        const newMutedState = !isMutedRef.current;
        localStreamRef.current.getAudioTracks().forEach(track => { track.enabled = !newMutedState; });
        setIsMuted(newMutedState); 
        updateOrAddParticipant(peerIdRef.current, undefined, displayNameRef.current, !newMutedState, isVideoEnabledRef.current, true);
       }, [updateOrAddParticipant]);

      const toggleVideo = useCallback(() => {
        if (!localStreamRef.current) { console.warn("Local stream not ready for video toggle."); return; }
        const newVideoEnabledState = !isVideoEnabledRef.current;
        localStreamRef.current.getVideoTracks().forEach(track => { track.enabled = newVideoEnabledState; });
        if (newVideoEnabledState) {
            localStreamRef.current.getAudioTracks().forEach(track => { track.enabled = !isMutedRef.current; });
        }
        setIsVideoEnabled(newVideoEnabledState); 
        updateOrAddParticipant(peerIdRef.current, undefined, displayNameRef.current, !isMutedRef.current, newVideoEnabledState, true);
       }, [updateOrAddParticipant]);

      const formatTime = useCallback((totalSeconds) => { 
        const hours = Math.floor(totalSeconds / 3600); const minutes = Math.floor((totalSeconds % 3600) / 60); const seconds = totalSeconds % 60;
        return `${hours > 0 ? String(hours).padStart(2, '0')+':' : ''}${String(minutes).padStart(2, '0')}:${String(seconds).padStart(2, '0')}`;
      }, []);
      
      const handleToggleLayoutMenu = useCallback(() => {
        setShowLayoutMenu(prev => !prev);
        if (!showLayoutMenu) showControlsTemporarily(); 
      }, [showLayoutMenu, showControlsTemporarily]);

      const handleSetViewMode = useCallback((mode) => {
        setViewMode(mode);
        setShowLayoutMenu(false); 
      }, []);
      
      const handleSetActiveSpeaker = useCallback((id) => {
        setActiveSpeakerId(id);
        if (pinnedPeerId && pinnedPeerId !== id) setPinnedPeerId(null); 
      }, [pinnedPeerId]);

      const handleToggleFilmstrip = useCallback(() => setIsFilmstripVisible(prev => !prev), []);

      const handleTogglePin = useCallback((targetPeerId) => {
        setPinnedPeerId(prevPinnedId => {
            const newPinnedId = prevPinnedId === targetPeerId ? null : targetPeerId;
            if (newPinnedId && viewMode === 'speaker') {
                setActiveSpeakerId(newPinnedId);
            }
            return newPinnedId;
        });
      }, [viewMode]); 

      useEffect(() => { 
        if (pinnedPeerId && viewMode === 'speaker' && activeSpeakerId !== pinnedPeerId) {
            setActiveSpeakerId(pinnedPeerId);
        }
      }, [pinnedPeerId, viewMode, activeSpeakerId]);


      const handleCopyPeerId = useCallback(() => {  
        if (peerId) { navigator.clipboard.writeText(peerId).then(() => { setCopied(true); setTimeout(() => setCopied(false), 2000); }).catch(err => console.error('Failed to copy: ', err));}
      }, [peerId]);

      return (
        <div ref={appContainerRef} className="w-full h-screen flex flex-col bg-gray-900">
          {!joined ? (
            <div className="flex-grow flex flex-col items-center justify-center p-4">
              <h1 className="text-4xl font-bold text-purple-400 mb-2">SyncLite Pro - V4.7</h1>
              <p className="text-xs text-gray-400 mb-6">Video Chat become Simple</p>
              <div className="bg-gray-800 p-6 sm:p-8 rounded-xl shadow-2xl w-full max-w-md space-y-5">
                <p className="text-center text-sm flex items-center justify-center">
                  <strong className="mr-2">Your Peer ID:</strong> 
                  <span className="text-green-400 break-all">{peerId || 'Connecting...'}</span>
                  {peerId && (<button onClick={handleCopyPeerId} className="copy-button" disabled={copied} title="Copy Peer ID">{copied ? 'Copied!' : <CopyIcon/>}</button>)}
                </p>
                {peerId && (<div><label htmlFor="displayNameInput" className="block text-xs font-medium text-gray-300 mb-1">Your Name</label><input id="displayNameInput" className="border-transparent p-3 w-full rounded-md bg-gray-700 text-white placeholder-gray-500 focus:ring-2 focus:ring-purple-500" placeholder="Enter your display name" value={displayName} onChange={e => {setDisplayName(e.target.value); setNameEntered(e.target.value.trim() !== '');}}/></div>)}
                {nameEntered && peerId && (<div><label htmlFor="roomIdInput" className="block text-xs font-medium text-gray-300 mb-1">Room ID</label><input id="roomIdInput" className="border-transparent p-3 w-full rounded-md bg-gray-700 text-white placeholder-gray-500 focus:ring-2 focus:ring-purple-500" placeholder="Enter Room ID or your ID to host" value={roomId} onChange={e => setRoomId(e.target.value)}/></div>)}
                <p className="text-center text-xs text-red-400 h-4">{status.startsWith("Ready") ? (peerId ? (nameEntered ? "Enter Room ID." : "Enter Name.") : "Connecting Peer ID...") : status}</p>
                <button onClick={joinRoom} className="bg-purple-600 hover:bg-purple-700 text-white py-3 px-4 rounded-md w-full font-semibold disabled:opacity-50" disabled={!peerId || !roomId.trim() || !displayName.trim()}> {(roomId === peerId && peerId && displayName.trim()) ? 'Start & Host Chat' : 'Join Chat Room'} </button>
              </div>
            </div>
          ) : (
            <div className="flex-grow flex flex-col overflow-hidden w-full relative">
              <StatusBar currentTime={elapsedTime} userDisplayName={displayNameRef.current} currentNetworkType={networkType} formatTimeFunc={formatTime} />
              <VideoLayout 
                videos={videos} viewMode={viewMode} activeSpeakerId={activeSpeakerId}
                isLocalVideoGloballyEnabled={isVideoEnabled} isLocalAudioGloballyMuted={isMuted}
                localStreamForPlayer={localStreamRef.current} 
                onSetActiveSpeaker={handleSetActiveSpeaker} onSetViewMode={handleSetViewMode}
                isFilmstripVisible={isFilmstripVisible}
                pinnedPeerId={pinnedPeerId} onTogglePin={handleTogglePin}
              />
              <div 
                className={`absolute bottom-0 left-0 right-0 p-3 sm:p-4 z-20 transition-all duration-300 ease-in-out ${controlsVisible ? 'opacity-100 translate-y-0' : 'opacity-0 translate-y-full pointer-events-none'}`} // Added pointer-events-none when hidden
                onMouseEnter={() => { clearTimeout(controlsTimeoutRef.current); setControlsVisible(true); }} 
                onMouseLeave={showControlsTemporarily} 
              >
                <div className="bg-gray-800/90 backdrop-blur-sm p-3 sm:p-3 rounded-xl shadow-md max-w-max mx-auto"> {/* pointer-events-auto on this if needed for children */}
                    <Controls 
                        isMuted={isMuted} isVideoEnabled={isVideoEnabled}
                        onToggleMute={toggleMute} onToggleVideo={toggleVideo}
                        onToggleLayoutMenu={handleToggleLayoutMenu} onEndCall={() => endCall(true)}
                        onToggleFilmstrip={handleToggleFilmstrip} isFilmstripVisible={isFilmstripVisible}
                        videoCount={videos.filter(v => v.stream || v.isLocal).length}
                        currentViewMode={viewMode}
                    />
                </div>
                {showLayoutMenu && (
                    <div className="absolute bottom-full left-1/2 transform -translate-x-1/2 mb-1">
                        <LayoutMenu onSetViewMode={handleSetViewMode} currentViewMode={viewMode} closeMenu={() => setShowLayoutMenu(false)} />
                    </div>
                )}
              </div>
            </div>
          )}
        </div>);
    }
    ReactDOM.createRoot(document.getElementById('root')).render(<App />);
  </script>
</body>
</html>
