<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no"/>
  <title>SyncLite Pro Video Chat - V3.4</title>
  <script src="https://cdn.tailwindcss.com"></script>
  <script src="https://unpkg.com/react@18/umd/react.development.js"></script>
  <script src="https://unpkg.com/react-dom@18/umd/react-dom.development.js"></script>
  <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>
  <script src="https://webrtc.github.io/adapter/adapter-latest.js"></script>
  <script src="https://unpkg.com/peerjs@1.5.2/dist/peerjs.min.js"></script>
  <style>
    .no-scrollbar::-webkit-scrollbar { display: none; }
    .no-scrollbar { -ms-overflow-style: none; scrollbar-width: none; }
    .video-container { position: relative; background-color: #1a202c; overflow: hidden; border-radius: 0.375rem; }
    .participant-name { position: absolute; bottom: 6px; left: 6px; background-color: rgba(0, 0, 0, 0.65); color: white; font-size: 0.7rem; padding: 3px 8px; border-radius: 0.25rem; max-width: calc(100% - 12px); overflow: hidden; text-overflow: ellipsis; white-space: nowrap; z-index: 10; }
    .video-element { width: 100%; height: 100%; display: block; }
    .disabled-video-placeholder { width: 100%; height: 100%; display: flex; flex-direction: column; align-items: center; justify-content: center; background-color: #2d3748; color: #a0aec0; font-size: 0.875rem; }
    .shadow-up { box-shadow: 0 -4px 6px -1px rgba(0, 0, 0, 0.1), 0 -2px 4px -1px rgba(0, 0, 0, 0.06); }
  </style>
</head>
<body>
  <div id="root" class="min-h-screen bg-gray-900 flex flex-col items-center text-white"></div>

  <script type="text/babel">
    const { useState, useRef, useEffect, useCallback } = React;

    function App() {
      const [peerId, setPeerId] = useState('');
      const [roomId, setRoomId] = useState('');
      const [status, setStatus] = useState('Initializing Peer Connection...'); // More specific initial status
      const [videos, setVideos] = useState([]); 
      const [joined, setJoined] = useState(false);
      const [isMuted, setIsMuted] = useState(false);
      const [isVideoEnabled, setIsVideoEnabled] = useState(true);
      const [viewMode, setViewMode] = useState('speaker'); 
      const [activeSpeakerId, setActiveSpeakerId] = useState(null); 

      const peerRef = useRef(null);
      const connectionsRef = useRef({});
      const callsRef = useRef({});
      const localStreamRef = useRef(null);

      // Moved PeerJS initialization into its own useEffect for clarity
      useEffect(() => {
        console.log("Attempting to initialize PeerJS...");
        // Ensure any existing peer is destroyed before creating a new one if this effect were to re-run
        if (peerRef.current) {
            console.log("Destroying existing peer instance before re-initializing.");
            peerRef.current.destroy();
        }

        const newPeerInstance = new Peer(undefined, {
          host: '0.peerjs.com', 
          port: 443, 
          path: '/peerjs', 
          secure: true, 
          debug: 3, // Max debug level for detailed logs
        });
        peerRef.current = newPeerInstance;
        console.log("PeerJS: New peer instance created with temporary ID:", newPeerInstance.id);

        newPeerInstance.on('open', (id) => {
          console.log('PeerJS: "open" event. Connected with ID:', id);
          // Check if the peer instance is still the current one
          if (peerRef.current && peerRef.current === newPeerInstance) {
            setPeerId(id);
            setActiveSpeakerId(id); 
            setStatus('Ready. Share your Peer ID or enter Room ID.');
          } else {
            console.warn("PeerJS 'open' event received for a stale peer instance. Closing it.");
            newPeerInstance.destroy(); // Clean up the stale instance
          }
        });

        newPeerInstance.on('connection', (conn) => {
          if (!peerRef.current || peerRef.current.disconnected || peerRef.current !== newPeerInstance) {
            console.warn("PeerJS 'connection' event on stale/disconnected peer. Ignoring.");
            return;
          }
          console.log('PeerJS: "connection" event from', conn.peer);
          connectionsRef.current[conn.peer] = conn;
          conn.on('data', data => handleSignalingData(data, conn));
          conn.on('close', () => handleDisconnect(conn.peer, 'Data connection closed'));
          conn.on('error', err => handleDisconnect(conn.peer, `Data connection error: ${err.type || err.message}`));
        });
        
        newPeerInstance.on('call', (call) => {
          if (!peerRef.current || peerRef.current.disconnected || peerRef.current !== newPeerInstance) {
            console.warn("PeerJS 'call' event on stale/disconnected peer. Ignoring.");
            return;
          }
          console.log('PeerJS: "call" event from', call.peer);
          if (localStreamRef.current) {
            call.answer(localStreamRef.current);
          } else { 
            console.warn('Call received from', call.peer, 'but local stream is not ready. Call not answered.');
            return; 
          }
          call.on('stream', remoteStream => addVideo(call.peer, remoteStream, false));
          callsRef.current[call.peer] = call;
          call.on('close', () => handleDisconnect(call.peer, 'Call closed'));
          call.on('error', (err) => handleDisconnect(call.peer, `Call error: ${err.type || err.message}`));
        });

        newPeerInstance.on('disconnected', () => {
          console.warn('PeerJS: "disconnected" event from signaling server.');
          // PeerJS logs "Disconnected from PeerJS. Reconnecting..." internally when debug >= 2.
          // Only set status if the current peer is the one that disconnected.
          if (peerRef.current && peerRef.current === newPeerInstance && !peerRef.current.destroyed) {
             setStatus('Connection to signaling server lost. Attempting to reconnect...');
          }
        });

        newPeerInstance.on('close', () => {
          // This event is emitted when the peer is_destroyed_ (e.g., by calling peer.destroy()).
          console.log('PeerJS: "close" event (peer has been destroyed).');
           if (peerRef.current && peerRef.current === newPeerInstance) {
             //setStatus('Peer connection instance closed.'); // Optional: can be noisy if part of normal cleanup
           }
        });

        newPeerInstance.on('error', (err) => {
          console.error('PeerJS: "error" event:', err);
          let message = `PeerJS Error: ${err.type || 'Unknown'}`;
          if (err.message) message += ` - ${err.message}`;
          
          if (err.type === 'network') message = 'Network error connecting to signaling server. Check internet/firewall.';
          else if (err.type === 'socket-error') message = 'Signaling socket error. PeerJS may attempt to reconnect.';
          else if (err.type === 'socket-closed') message = 'Signaling socket closed unexpectedly. PeerJS may attempt to reconnect.';
          else if (err.type === 'server-error') message = 'PeerJS server error. Please try again later.';
          else if (err.type === 'unavailable-id') message = `The ID '${roomId || peerId || ''}' is already taken.`;
          else if (err.type === 'webrtc') message = 'WebRTC connection error (usually between peers).';
          // Add more specific error types as needed from PeerJS documentation

          // Only set status if the error pertains to the current active peer instance
          if (peerRef.current && peerRef.current === newPeerInstance && !peerRef.current.destroyed) {
            setStatus(message);
          }

          // If the error is fatal for this peer instance, it might already be destroyed or become unusable.
          // Example: 'invalid-key' or 'browser-incompatible'.
          if (err.type === 'browser-incompatible' || err.type === 'socket-error' && !newPeerInstance.disconnected) {
            // For some critical errors, explicitly destroy to prevent further issues
            console.warn("Critical PeerJS error, destroying instance:", err.type);
            if (peerRef.current === newPeerInstance) peerRef.current.destroy();
          }
        });

        return () => {
          console.log('useEffect cleanup: Destroying PeerJS instance with temp ID:', newPeerInstance.id);
          newPeerInstance.destroy(); // Destroy the instance created in this effect
          if (peerRef.current === newPeerInstance) {
            peerRef.current = null; // Nullify the ref if it pointed to this instance
          }
          // Clear associated refs for calls and connections
          callsRef.current = {};
          connectionsRef.current = {};
          // Stop local media tracks if they exist
          localStreamRef.current?.getTracks().forEach(track => track.stop());
          localStreamRef.current = null;
          // setPeerId(''); // Resetting peerId might cause UI flicker if rejoining
          console.log("PeerJS cleanup complete.");
        };
      }, []); // Empty dependency array ensures this runs once on mount and cleans up on unmount.


      useEffect(() => { // Effect for managing activeSpeakerId based on videos
        if (!joined) return;
        const activeSpeakerStillExists = videos.some(v => v.peerId === activeSpeakerId);
        if (activeSpeakerId && !activeSpeakerStillExists) {
          setActiveSpeakerId(videos.find(v => v.isLocal)?.peerId || videos[0]?.peerId || null);
        } else if (!activeSpeakerId && videos.length > 0) {
          setActiveSpeakerId(videos.find(v => v.isLocal)?.peerId || videos[0]?.peerId);
        }
        if (videos.length <= 1 && viewMode === 'gallery') setViewMode('speaker');
      }, [videos, activeSpeakerId, joined, peerId, viewMode]);

      const handleSignalingData = (data, conn) => { /* ... unchanged ... */ 
        switch (data.type) {
          case 'join-room': 
            conn.send({ type: 'peer-list', peers: Object.keys(callsRef.current) });
            Object.values(connectionsRef.current).forEach(c => {
              if (c.peer !== conn.peer && c.open) c.send({ type: 'new-peer', peerId: conn.peer });
            });
            if (localStreamRef.current && !callsRef.current[conn.peer]) callPeer(conn.peer);
            break;
          case 'peer-list': 
            data.peers.forEach(pid => {
              if (pid !== peerId && !callsRef.current[pid] && !connectionsRef.current[pid]) connectAndCallPeer(pid);
            });
            break;
          case 'new-peer': 
            if (data.peerId !== peerId && !callsRef.current[data.peerId] && !connectionsRef.current[data.peerId]) {
              connectAndCallPeer(data.peerId);
            }
            break;
        }
      };
      const addVideo = (pId, stream, isLocal = false) => { /* ... unchanged ... */ 
        setVideos(prev => prev.some(v => v.peerId === pId) ? prev.map(v => v.peerId === pId ? { ...v, stream } : v) : [...prev, { peerId: pId, stream, isLocal }]);
      };
      const handleDisconnect = (pId, reason = "Unknown") => { /* ... unchanged ... */ 
        setVideos(prev => prev.filter(v => v.peerId !== pId));
        callsRef.current[pId]?.close(); delete callsRef.current[pId];
        connectionsRef.current[pId]?.close(); delete connectionsRef.current[pId];
        console.log(`Peer ${pId} disconnected: ${reason}`);
      };
      const joinRoom = async () => { /* ... unchanged ... */ 
        if (!peerRef.current || peerRef.current.disconnected) {
            setStatus("PeerJS not connected. Please wait or refresh.");
            console.error("Join attempt while PeerJS is not connected or object is missing.");
            // Optionally, try to re-initialize PeerJS here or guide the user.
            // For now, just prevent joining.
            return;
        }
        if (!roomId.trim()) { setStatus("Room ID required."); return; }
        setStatus('Getting media...');
        try {
          const stream = await navigator.mediaDevices.getUserMedia({ 
            video: true, audio: { echoCancellation: true, noiseSuppression: true, autoGainControl: true }
          });
          localStreamRef.current = stream;
          stream.getVideoTracks().forEach(t => t.enabled = isVideoEnabled);
          stream.getAudioTracks().forEach(t => t.enabled = !isMuted);
          addVideo(peerId, stream, true);
          setJoined(true);
          setStatus('Joining room...');

          if (roomId !== peerId) { 
            const conn = peerRef.current.connect(roomId);
            if (!conn) { setStatus('Failed to initiate connection to host.'); setJoined(false); return; }
            connectionsRef.current[roomId] = conn;
            conn.on('open', () => {
              setStatus(`Connected to room. Others can join.`);
              conn.send({ type: 'join-room', peerId });
            });
            conn.on('data', data => handleSignalingData(data, conn));
            conn.on('close', () => { setStatus(`Disconnected from host.`); handleDisconnect(roomId, 'Host connection closed'); });
            conn.on('error', err => { setStatus(`Host connection error: ${err.type}`); handleDisconnect(roomId, `Host conn error: ${err.type}`); setJoined(false); });
          } else { 
            setStatus(`Hosting room. Share your ID.`);
          }
        } catch (err) {
          setStatus(`Media Error: ${err.name}. Check permissions.`);
          localStreamRef.current?.getTracks().forEach(t => t.stop());
          setJoined(false);
        }
      };
      const callPeer = (targetPeerId) => { /* ... unchanged ... */ 
        if (!localStreamRef.current || callsRef.current[targetPeerId]) return;
        if (!peerRef.current || peerRef.current.disconnected) {
            console.error("Cannot call peer: PeerJS not connected.");
            setStatus("Cannot call: PeerJS connection issue.");
            return;
        }
        const call = peerRef.current.call(targetPeerId, localStreamRef.current);
        if (!call) { console.error("Failed to call", targetPeerId); return; }
        callsRef.current[targetPeerId] = call;
        call.on('stream', remoteStream => addVideo(targetPeerId, remoteStream, false));
        call.on('close', () => handleDisconnect(targetPeerId, `Call to ${targetPeerId} closed`));
        call.on('error', (err) => handleDisconnect(targetPeerId, `Call error ${targetPeerId}: ${err.type}`));
      };
      const connectAndCallPeer = (targetPeerId) => { /* ... unchanged ... */ 
        if (targetPeerId === peerId || connectionsRef.current[targetPeerId] || callsRef.current[targetPeerId]) return;
        if (!peerRef.current || peerRef.current.disconnected) {
            console.error("Cannot connect/call peer: PeerJS not connected.");
            setStatus("Cannot connect: PeerJS connection issue.");
            return;
        }
        const conn = peerRef.current.connect(targetPeerId);
        if (!conn) { console.error("Failed to connect to new peer", targetPeerId); return; }
        connectionsRef.current[targetPeerId] = conn;
        conn.on('open', () => callPeer(targetPeerId));
        conn.on('data', data => handleSignalingData(data, conn));
        conn.on('close', () => handleDisconnect(targetPeerId, `Data conn with ${targetPeerId} closed`));
        conn.on('error', err => handleDisconnect(targetPeerId, `Data conn error ${targetPeerId}: ${err.type}`));
      };
      const toggleMute = () => { /* ... unchanged ... */ 
         localStreamRef.current?.getAudioTracks().forEach(t => { t.enabled = !t.enabled; setIsMuted(!t.enabled); });
      };
      const toggleVideo = () => { /* ... unchanged ... */ 
        localStreamRef.current?.getVideoTracks().forEach(t => { t.enabled = !t.enabled; setIsVideoEnabled(!t.enabled); });
      };

      // JSX for UI elements (VideoPlaceholder, VideoPlayer, ControlButton, Icons) remains the same as "SyncLite Pro"
      // ... (Same UI JSX as the previous "SyncLite Pro" version) ...
      const getParticipantName = (pId, isLocal) => isLocal ? `You (${pId.substring(0, 6)})` : `Peer (${pId.substring(0, 6)})`;
      const VideoPlaceholder = ({ text }) => ( /* ... same ... */ <div className="disabled-video-placeholder"><svg xmlns="http://www.w3.org/2000/svg" className="h-12 w-12 mb-2" fill="none" viewBox="0 0 24 24" stroke="currentColor" strokeWidth="1"><path strokeLinecap="round" strokeLinejoin="round" d="M15 10l4.553-2.276A1 1 0 0121 8.618v6.764a1 1 0 01-1.447.894L15 14M4 8h11a1 1 0 011 1v6a1 1 0 01-1 1H4a1 1 0 01-1-1V9a1 1 0 011-1zM1.5 6L0 7.5L3 10.5L1.5 12L0 13.5L3 16.5L4.5 15L3 13.5L4.5 12L3 10.5L4.5 9L1.5 6zM22.5 6L24 7.5L21 10.5L22.5 12L24 13.5L21 16.5L19.5 15L21 13.5L19.5 12L21 10.5L19.5 9L22.5 6z" /></svg>{text}</div>);
      const VideoPlayer = ({ stream, isLocal, isVideoActuallyEnabled, objectFitClass = "object-cover" }) => { /* ... same ... */ const videoRef = useRef(null); useEffect(() => { if (videoRef.current && stream) videoRef.current.srcObject = stream; }, [stream]); if (isLocal && !isVideoActuallyEnabled) return <VideoPlaceholder text="Your video is off" />; return <video ref={videoRef} autoPlay playsInline muted={isLocal} className={`video-element ${objectFitClass}`} />;};
      const activeSpeakerVideo = videos.find(v => v.peerId === activeSpeakerId);
      const filmstripVideos = videos.filter(v => v.peerId !== activeSpeakerId);
      const galleryCols = videos.length <= 1 ? 1 : (videos.length <= 4 ? 2 : (videos.length <= 9 ? 3 : 4));
      const MicOnIcon = <svg xmlns="http://www.w3.org/2000/svg" className="h-5 w-5 sm:h-6 sm:w-6" fill="none" viewBox="0 0 24 24" stroke="currentColor"><path strokeLinecap="round" strokeLinejoin="round" strokeWidth="2" d="M19 11a7 7 0 01-7 7m0 0a7 7 0 01-7-7m7 7v4m0 0H8m4 0h4m-4-8a3 3 0 01-3-3V5a3 3 0 116 0v6a3 3 0 01-3 3z" /></svg>;
      const MicOffIcon = <svg xmlns="http://www.w3.org/2000/svg" className="h-5 w-5 sm:h-6 sm:w-6" fill="none" viewBox="0 0 24 24" stroke="currentColor"><path strokeLinecap="round" strokeLinejoin="round" strokeWidth="2" d="M19 11a7 7 0 01-7 7m0 0a7 7 0 01-7-7m7 7v4m0 0H8m4 0h4m-4-8a3 3 0 01-3-3V5a3 3 0 116 0v6a3 3 0 01-3 3zM12 18.5A4.5 4.5 0 0016.5 14H8a4.5 4.5 0 004 4.5zM6 18L18 6M6 6l12 12" /></svg>; 
      const VideoOnIcon = <svg xmlns="http://www.w3.org/2000/svg" className="h-5 w-5 sm:h-6 sm:w-6" fill="none" viewBox="0 0 24 24" stroke="currentColor"><path strokeLinecap="round" strokeLinejoin="round" strokeWidth="2" d="M15 10l4.553-2.276A1 1 0 0121 8.618v6.764a1 1 0 01-1.447.894L15 14M4 8h11a1 1 0 011 1v6a1 1 0 01-1 1H4a1 1 0 01-1-1V9a1 1 0 011-1z" /></svg>;
      const VideoOffIcon = <svg xmlns="http://www.w3.org/2000/svg" className="h-5 w-5 sm:h-6 sm:w-6" fill="none" viewBox="0 0 24 24" stroke="currentColor"><path strokeLinecap="round" strokeLinejoin="round" strokeWidth="2" d="M15 10l4.553-2.276A1 1 0 0121 8.618v6.764a1 1 0 01-1.447.894L15 14M4 8h11a1 1 0 011 1v6a1 1 0 01-1 1H4a1 1 0 01-1-1V9a1 1 0 011-1zm0 0l6.364-3.182M10.364 4.818L4 8m6.364-3.182l-1.455-2.723M6 18L18 6M6 6l12 12" /></svg>; 
      const GalleryLayoutIcon = <svg xmlns="http://www.w3.org/2000/svg" className="h-5 w-5 sm:h-6 sm:w-6" fill="none" viewBox="0 0 24 24" stroke="currentColor"><path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M4 6a2 2 0 012-2h2a2 2 0 012 2v2a2 2 0 01-2 2H6a2 2 0 01-2-2V6zM14 6a2 2 0 012-2h2a2 2 0 012 2v2a2 2 0 01-2 2h-2a2 2 0 01-2-2V6zM4 16a2 2 0 012-2h2a2 2 0 012 2v2a2 2 0 01-2 2H6a2 2 0 01-2-2v-2zM14 16a2 2 0 012-2h2a2 2 0 012 2v2a2 2 0 01-2 2h-2a2 2 0 01-2-2v-2z" /></svg>;
      const SpeakerLayoutIcon = <svg xmlns="http://www.w3.org/2000/svg" className="h-5 w-5 sm:h-6 sm:w-6" fill="none" viewBox="0 0 24 24" stroke="currentColor"><path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M4 6h16M4 12h16M4 18h7" /></svg>;
      const ControlButton = ({ title, onClick, children, active = false, activeColor = "bg-red-500" }) => ( /* ... same ... */ <button title={title} onClick={onClick} className={`p-2.5 sm:p-3 rounded-full text-white transition-colors duration-150 ease-in-out ${active ? activeColor : 'bg-gray-600 hover:bg-gray-500'} focus:outline-none focus:ring-2 focus:ring-purple-500 focus:ring-opacity-50`}>{children}</button>);

      return (
        <div className="w-full h-screen flex flex-col bg-gray-900">
          {!joined ? (
            <div className="flex-grow flex flex-col items-center justify-center p-4">
              <h1 className="text-4xl font-bold text-purple-400 mb-8">SyncLite Pro - V3.4</h1>
              <div className="bg-gray-800 p-6 sm:p-8 rounded-xl shadow-2xl w-full max-w-lg space-y-6">
                <p className="text-center text-sm"><strong>Your Peer ID:</strong> <span className="text-green-400 break-all block mt-1">{peerId || 'Connecting...'}</span></p>
                <p className="text-center text-xs text-red-400 h-4">{!peerId ? status : (status.startsWith("Ready") ? "" : status)}</p> {/* Show status prominently if no peerId */}
                <div>
                  <label htmlFor="roomIdInput" className="block text-sm font-medium text-gray-300 mb-1">Room ID</label>
                  <input id="roomIdInput" className="border-transparent p-3 w-full rounded-md bg-gray-700 text-white placeholder-gray-500 focus:ring-2 focus:ring-purple-500 focus:outline-none"
                    placeholder="Enter Room ID or your ID to host" value={roomId} onChange={e => setRoomId(e.target.value)} disabled={!peerId} />
                </div>
                <button onClick={joinRoom} className="bg-purple-600 hover:bg-purple-700 text-white py-3 px-4 rounded-md w-full font-semibold disabled:opacity-50 transition-all duration-150 ease-in-out"
                  disabled={!peerId || !roomId.trim()}>
                  {roomId === peerId ? 'Start & Host Chat' : 'Join Chat Room'}
                </button>
              </div>
            </div>
          ) : (
             // ... Main chat UI ... (Same as before)
            <div className="flex-grow flex flex-col overflow-hidden">
              <div className="flex-grow flex flex-col relative bg-black p-1 sm:p-2">
                {viewMode === 'speaker' ? (
                  <div className="flex flex-col flex-grow h-full space-y-1 sm:space-y-2">
                    <div className="flex-grow video-container">
                      {activeSpeakerVideo ? (
                        <>
                          <VideoPlayer stream={activeSpeakerVideo.stream} isLocal={activeSpeakerVideo.isLocal}
                            isVideoActuallyEnabled={activeSpeakerVideo.isLocal ? isVideoEnabled : true} objectFitClass="object-contain"/>
                          <div className="participant-name">{getParticipantName(activeSpeakerVideo.peerId, activeSpeakerVideo.isLocal)}</div>
                        </>
                      ) : <VideoPlaceholder text="No active speaker" />}
                    </div>
                    {videos.length > 1 && (
                       <div className="flex-shrink-0 h-24 sm:h-32 bg-gray-800 p-1 sm:p-2 flex space-x-1 sm:space-x-2 overflow-x-auto no-scrollbar items-center rounded-md">
                        {filmstripVideos.map(video => (
                          <div key={video.peerId} className="video-container w-28 sm:w-40 h-full cursor-pointer border-2 border-transparent hover:border-purple-500 focus:border-purple-600"
                            onClick={() => setActiveSpeakerId(video.peerId)} tabIndex="0">
                            <VideoPlayer stream={video.stream} isLocal={video.isLocal} isVideoActuallyEnabled={video.isLocal ? isVideoEnabled : true}/>
                            <div className="participant-name">{getParticipantName(video.peerId, video.isLocal)}</div>
                          </div>
                        ))}
                      </div>
                    )}
                  </div>
                ) : ( 
                  <div className={`flex-grow p-1 sm:p-2 grid gap-1 sm:gap-2 overflow-y-auto grid-cols-${galleryCols}`}>
                    {videos.map(video => (
                      <div key={video.peerId} className="video-container cursor-pointer border-2 border-transparent hover:border-purple-500 focus:border-purple-600 aspect-video"
                        onClick={() => { setActiveSpeakerId(video.peerId); setViewMode('speaker');}} tabIndex="0">
                        <VideoPlayer stream={video.stream} isLocal={video.isLocal} isVideoActuallyEnabled={video.isLocal ? isVideoEnabled : true} />
                        <div className="participant-name">{getParticipantName(video.peerId, video.isLocal)}</div>
                      </div>
                    ))}
                     {videos.length === 0 && <div className="disabled-video-placeholder col-span-full row-span-full"><VideoPlaceholder text="No one is here" /></div>}
                  </div>
                )}
              </div>

              <div className="flex-shrink-0 bg-gray-800 p-3 sm:p-4 flex justify-center items-center space-x-3 sm:space-x-4 shadow-up">
                <ControlButton title={isMuted ? "Unmute" : "Mute"} onClick={toggleMute} active={isMuted} activeColor="bg-red-600">
                  {isMuted ? MicOffIcon : MicOnIcon}
                </ControlButton>
                <ControlButton title={isVideoEnabled ? "Cam Off" : "Cam On"} onClick={toggleVideo} active={!isVideoEnabled} activeColor="bg-red-600">
                  {isVideoEnabled ? VideoOnIcon : VideoOffIcon}
                </ControlButton>
                {videos.length > 1 && (
                  <ControlButton title={viewMode === 'gallery' ? "Speaker View" : "Gallery View"} 
                                 onClick={() => setViewMode(prev => prev === 'gallery' ? 'speaker' : 'gallery')}>
                    {viewMode === 'gallery' ? SpeakerLayoutIcon : GalleryLayoutIcon}
                  </ControlButton>
                )}
              </div>
            </div>
          )}
        </div>
      );
    }
    ReactDOM.createRoot(document.getElementById('root')).render(<App />);
  </script>
</body>
</html>
