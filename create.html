<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>L3 Squad Meeting Agent</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;600;700&display=swap" rel="stylesheet">
    <style>
        body {
            font-family: 'Inter', sans-serif;
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        /* Custom scrollbar for chat area */
        .chat-messages-container::-webkit-scrollbar {
            width: 8px;
        }
        .chat-messages-container::-webkit-scrollbar-track {
            background: #f1f1f1;
            border-radius: 10px;
        }
        .chat-messages-container::-webkit-scrollbar-thumb {
            background: #888;
            border-radius: 10px;
        }
        .chat-messages-container::-webkit-scrollbar-thumb:hover {
            background: #555;
        }
    </style>
</head>
<body class="h-screen flex flex-col">
    <div id="root" class="flex flex-col flex-1"></div>

    <script crossorigin src="https://unpkg.com/react@18/umd/react.production.min.js"></script>
    <script crossorigin src="https://unpkg.com/react-dom@18/umd/react-dom.production.min.js"></script>
    <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>

    <script type="text/babel">
        // Main App component for the chat application
        function App() {
            const [messages, setMessages] = React.useState([]);
            const [inputMessage, setInputMessage] = React.useState('');
            const [isLoading, setIsLoading] = React.useState(false);
            const [error, setError] = React.useState(null);
            const [geminiApiKey, setGeminiApiKey] = React.useState('');
            // The Google App Script Web App URL is now hardcoded and not exposed in UI
            const appScriptUrl = "https://script.google.com/macros/s/AKfycbxX4c1KWOo_HE-Lhci18CE6bsLF1BlHvw2cViq3gHV5A7-IYU1UOVUy9jrO91fB8AEX/exec";

            const messagesEndRef = React.useRef(null);

            React.useEffect(() => {
                messagesEndRef.current?.scrollIntoView({ behavior: 'smooth' });
            }, [messages]);

            const handleInputChange = (e) => {
                setInputMessage(e.target.value);
            };

            const handleGeminiApiKeyChange = (e) => {
                setGeminiApiKey(e.target.value);
            };

            // Define all the tools (functions) the Gemini model can call
            const tools = [
                {
                    functionDeclarations: [
                        // Tool for adding general records to a Google Sheet
                        {
                            name: 'addRecordToSheet',
                            description: 'Adds a new record (row) to a specified Google Sheet. The Google App Script will determine the target sheet based on the action.',
                            parameters: {
                                type: 'OBJECT',
                                properties: {
                                    // The App Script will likely infer sheetId/sheetName based on the action,
                                    // but we keep these parameters for the AI to extract if it deems necessary
                                    sheetId: {
                                        type: 'STRING',
                                        description: 'The ID of the Google Spreadsheet. (Optional, App Script may infer)',
                                    },
                                    sheetName: {
                                        type: 'STRING',
                                        description: 'The name of the sheet within the spreadsheet (e.g., "Sheet1"). (Optional, App Script may infer)',
                                    },
                                    recordData: {
                                        type: 'ARRAY',
                                        description: 'An array of values representing the row to be added. Each element is a column value.',
                                        items: {
                                            type: 'STRING',
                                        },
                                    },
                                },
                                required: ['recordData'], // Only recordData is strictly required for the tool call
                            },
                        },
                        // NEW TOOL: createMeeting
                        {
                            name: 'createMeeting',
                            description: 'Creates a new meeting record in the meeting management system. The meeting_code will be automatically generated by the system.',
                            parameters: {
                                type: 'OBJECT',
                                properties: {
                                    title: {
                                        type: 'STRING',
                                        description: 'The title or subject of the meeting.',
                                    },
                                    host_guid: {
                                        type: 'NUMBER', // Assuming GUID is a number for simplicity or unique ID
                                        description: 'A unique numerical identifier for the meeting host.',
                                    },
                                    date: {
                                        type: 'STRING',
                                        description: 'The date of the meeting in DD/MM/YYYY format.',
                                    },
                                    planned_time: {
                                        type: 'STRING',
                                        description: 'The planned start time of the meeting in HH:MM:SS AM/PM format (e.g., "03:00:00 PM").',
                                    },
                                },
                                required: ['title', 'host_guid', 'date', 'planned_time'],
                            },
                        },
                        // NEW TOOL: updateMeetingCode
                        {
                            name: 'updateMeetingCode',
                            description: 'Updates the meeting code for an existing meeting identified by its meeting ID.',
                            parameters: {
                                type: 'OBJECT',
                                properties: {
                                    meeting_id: {
                                        type: 'NUMBER', // Assuming meeting_id is a number
                                        description: 'The numerical ID of the meeting to update.',
                                    },
                                    new_meeting_code: {
                                        type: 'STRING',
                                        description: 'The new unique code to assign to the meeting.',
                                    },
                                },
                                required: ['meeting_id', 'new_meeting_code'],
                            },
                        },
                    ],
                },
            ];

            // Function to send the message to the Gemini API
            const sendMessage = async () => {
                setError(null);

                if (!inputMessage.trim()) {
                    return;
                }

                // Basic validation for API keys
                if (!geminiApiKey.trim()) {
                    setError("Please enter your L3 API Key (Gemini API Key).");
                    return;
                }

                const newUserMessage = {
                    role: 'user',
                    parts: [{ text: inputMessage.trim() }],
                };

                // Add the user's message to the conversation history
                const updatedMessages = [...messages, newUserMessage];
                setMessages(updatedMessages);
                setInputMessage('');

                setIsLoading(true);

                try {
                    // First API call to Gemini: Ask it what to do
                    const geminiPayload = {
                        contents: updatedMessages,
                        tools: tools, // Provide all tool definitions to Gemini
                    };

                    const geminiApiUrl = `https://generativelanguage.googleapis.com/v1beta/models/gemini-2.0-flash:generateContent?key=${geminiApiKey}`;

                    const geminiResponse = await fetch(geminiApiUrl, {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify(geminiPayload),
                    });

                    if (!geminiResponse.ok) {
                        const errorData = await geminiResponse.json();
                        throw new Error(errorData.error?.message || 'Gemini API request failed.');
                    }

                    const geminiResult = await geminiResponse.json();

                    // Check if Gemini returned a tool call
                    if (geminiResult.candidates && geminiResult.candidates.length > 0 &&
                        geminiResult.candidates[0].content && geminiResult.candidates[0].content.parts &&
                        geminiResult.candidates[0].content.parts[0].functionCall) {

                        const functionCall = geminiResult.candidates[0].content.parts[0].functionCall;
                        const functionName = functionCall.name;
                        const functionArgs = functionCall.args;

                        // Add the model's tool call to the chat history for display
                        setMessages((prevMessages) => [
                            ...prevMessages,
                            {
                                role: 'model',
                                parts: [{
                                    text: `Calling tool: \`${functionName}(${JSON.stringify(functionArgs)})\``
                                }]
                            }
                        ]);

                        let appScriptActionPayload = null; // Payload for the Google App Script
                        let toolResponseName = functionName; // Name for the tool response to send back to Gemini

                        if (functionName === 'addRecordToSheet') {
                            appScriptActionPayload = {
                                action: "add_record_to_sheet", // Action name for your App Script
                                payload: {
                                    // Pass sheetId and sheetName if the AI extracts them, otherwise App Script should handle defaults
                                    sheetId: functionArgs.sheetId,
                                    sheetName: functionArgs.sheetName,
                                    recordData: functionArgs.recordData,
                                }
                            };
                        } else if (functionName === 'createMeeting') {
                            appScriptActionPayload = {
                                action: "create_meeting",
                                payload: {
                                    meeting_code: "NEW_AUTO_ID", // As per your API example
                                    title: functionArgs.title,
                                    host_guid: functionArgs.host_guid,
                                    date: functionArgs.date,
                                    planned_time: functionArgs.planned_time,
                                    started_time: "", // Default values
                                    ended_time: "",   // Default values
                                    active: 1,        // Default values
                                    migrated: 0       // Default values
                                }
                            };
                        } else if (functionName === 'updateMeetingCode') {
                            appScriptActionPayload = {
                                action: "update_meeting_code",
                                payload: {
                                    meeting_id: functionArgs.meeting_id,
                                    new_meeting_code: functionArgs.new_meeting_code,
                                }
                            };
                        } else {
                            setError(`Unknown function call: ${functionName}`);
                            setIsLoading(false);
                            return;
                        }

                        // Execute the tool call by sending data to your Google App Script
                        const appScriptResponse = await fetch(appScriptUrl, {
                            method: 'POST',
                            headers: { 'Content-Type': 'application/json' },
                            body: JSON.stringify(appScriptActionPayload),
                            mode: 'cors', // Ensure CORS mode for cross-origin requests
                            credentials: 'omit', // Omit credentials for public App Script web apps
                            redirect: 'follow' // Explicitly follow redirects
                        });

                        console.log('App Script Response Status:', appScriptResponse.status, appScriptResponse.statusText);
                        console.log('App Script Response Content-Type:', appScriptResponse.headers.get('Content-Type'));

                        let appScriptResult;
                        // Check if the App Script response was successful (HTTP 2xx)
                        if (appScriptResponse.ok) {
                            try {
                                // Try to parse as JSON if successful
                                appScriptResult = await appScriptResponse.json();
                            } catch (e) {
                                // If it's not JSON, read as text (e.g., empty response or simple text)
                                appScriptResult = await appScriptResponse.text();
                                console.warn("App Script response was OK, but not JSON. Raw text:", appScriptResult);
                                // Wrap in an object to maintain structure for functionResponse
                                appScriptResult = { status: 'success', message: 'App Script returned non-JSON success.', raw_response: appScriptResult };
                            }
                        } else {
                            // If App Script returns a non-2xx status, treat as error
                            let errorDetail = appScriptResponse.statusText;
                            try {
                                // Try to parse error response as JSON for more details
                                const errorJson = await appScriptResponse.json();
                                errorDetail = errorJson.message || JSON.stringify(errorJson);
                            } catch (e) {
                                // If it's not JSON, read as text (e.g., "Moved Temporarily" HTML)
                                errorDetail = await appScriptResponse.text();
                            }
                            throw new Error(`Google App Script responded with an error: ${appScriptResponse.status} - ${errorDetail}`);
                        }

                        // Send the tool's output back to the Gemini model
                        const toolOutputMessage = {
                            role: 'function', // Role for function output
                            parts: [{
                                functionResponse: {
                                    name: toolResponseName, // Use the original function name
                                    response: appScriptResult, // Send the actual result from App Script
                                },
                            }],
                        };

                        // Add the tool output to the messages
                        setMessages((prevMessages) => [...prevMessages, toolOutputMessage]);

                        // Second API call to Gemini: Send the tool output and get a natural language response
                        const followUpPayload = {
                            contents: [...updatedMessages, toolOutputMessage], // Send original messages + tool output
                            tools: tools, // Still include tools
                        };

                        const followUpResponse = await fetch(geminiApiUrl, {
                            method: 'POST',
                            headers: { 'Content-Type': 'application/json' },
                            body: JSON.stringify(followUpPayload),
                        });

                        if (!followUpResponse.ok) {
                            const errorData = await followUpResponse.json();
                            throw new Error(errorData.error?.message || 'Follow-up Gemini API request failed.');
                        }

                        const followUpResult = await followUpResponse.json();

                        if (followUpResult.candidates && followUpResult.candidates.length > 0 &&
                            followUpResult.candidates[0].content && followUpResult.candidates[0].content.parts &&
                            followUpResult.candidates[0].content.parts.length > 0) {
                            const modelResponseText = followUpResult.candidates[0].content.parts[0].text;
                            setMessages((prevMessages) => [...prevMessages, { role: 'model', parts: [{ text: modelResponseText }] }]);
                        } else {
                            throw new Error('Received an unexpected follow-up response from the model.');
                        }

                    } else if (geminiResult.candidates && geminiResult.candidates.length > 0 &&
                               geminiResult.candidates[0].content && geminiResult.candidates[0].content.parts &&
                               geminiResult.candidates[0].content.parts.length > 0) {
                        // If it's a regular text response from the model (no tool call)
                        const modelResponseText = geminiResult.candidates[0].content.parts[0].text;
                        const newModelMessage = {
                            role: 'model',
                            parts: [{ text: modelResponseText }],
                        };
                        setMessages((prevMessages) => [...prevMessages, newModelMessage]);
                    } else {
                        throw new Error('Received an empty or invalid response from the model.');
                    }
                } catch (err) {
                    console.error('Full error object:', err); // Log the full error object for debugging
                    let errorMessage = 'An unknown error occurred.';
                    if (err instanceof TypeError) {
                        errorMessage = `Network error or CORS issue: ${err.message}. Please check your internet connection and Google App Script deployment settings (especially 'Who has access' and 'New version' deployment).`;
                    } else if (err && typeof err.message === 'string' && err.message.length > 0) {
                        errorMessage = err.message;
                    } else if (err && typeof err === 'object' && Object.keys(err).length === 0) {
                        errorMessage = "An empty error object was returned. This often indicates a network issue or a problem with the App Script's response format that couldn't be parsed.";
                    } else if (typeof err === 'string') {
                        errorMessage = err; // If error is directly a string
                    }
                    setError(`Operation failed: ${errorMessage}`);
                    setMessages(messages); // Revert optimistic update
                } finally {
                    setIsLoading(false);
                }
            };

            return (
                <div className="flex flex-col h-screen bg-gray-100 font-sans">
                    {/* Header section of the chat application */}
                    <header className="bg-gradient-to-r from-blue-600 to-purple-700 text-white p-4 shadow-md rounded-b-lg">
                        <h1 className="text-2xl font-bold text-center">L3 Squad Meeting Agent</h1>
                    </header>

                    {/* Configuration Inputs */}
                    <div className="p-4 bg-white border-b border-gray-200 grid grid-cols-1 gap-3 rounded-t-lg shadow-inner">
                        <input
                            type="password"
                            className="p-3 border border-gray-300 rounded-lg focus:outline-none focus:ring-2 focus:ring-purple-500"
                            placeholder="Enter your L3 API Key (Gemini API Key)..."
                            value={geminiApiKey}
                            onChange={handleGeminiApiKeyChange}
                            disabled={isLoading}
                        />
                    </div>

                    {/* Chat messages display area - scrollable */}
                    <div className="flex-1 overflow-y-auto p-4 space-y-4 chat-messages-container">
                        {messages.length === 0 && (
                            <div className="text-center text-gray-500 mt-10">
                                Welcome to L3 Squad Meeting Agent!
                                <br />
                                Try: "Create a meeting titled 'Project Sync', host is 123, on 28/05/2025 at 10:00:00 AM."
                                <br />
                                Or: "Update meeting 5's code to 'NEWCODE123'."
                                <br />
                                (You can still try "Add a record for Alice, 25, Engineer" if your App Script supports it.)
                            </div>
                        )}
                        {/* Map through messages to display them */}
                        {messages.map((msg, index) => (
                            <div
                                key={index}
                                className={`flex ${msg.role === 'user' ? 'justify-end' : (msg.role === 'model' ? 'justify-start' : 'justify-center')}`}
                            >
                                <div
                                    className={`max-w-xl p-3 rounded-lg shadow-md ${
                                        msg.role === 'user'
                                            ? 'bg-blue-500 text-white rounded-br-none'
                                            : msg.role === 'model'
                                                ? 'bg-white text-gray-800 rounded-bl-none'
                                                : 'bg-yellow-100 text-yellow-800 border border-yellow-300' // Style for function output
                                    }`}
                                >
                                    {/* Render message parts based on role */}
                                    {msg.parts.map((part, partIndex) => (
                                        part.text ? <p key={partIndex}>{part.text}</p> :
                                        part.functionResponse ? (
                                            <pre key={partIndex} className="text-xs overflow-x-auto">
                                                Function Response ({part.functionResponse.name}): {JSON.stringify(part.functionResponse.response, null, 2)}
                                            </pre>
                                        ) : null
                                    ))}
                                </div>
                            </div>
                        ))}
                        {/* Loading indicator displayed when API call is in progress */}
                        {isLoading && (
                            <div className="flex justify-center">
                                <div className="p-3 bg-gray-200 text-gray-700 rounded-lg shadow-md animate-pulse">
                                    L3 Squad AI is thinking...
                                </div>
                            </div>
                        )}
                        {/* Error message display area */}
                        {error && (
                            <div className="flex justify-center">
                                <div className="p-3 bg-red-100 text-red-700 rounded-lg shadow-md border border-red-300">
                                    {error}
                                </div>
                            </div>
                        )}
                        <div ref={messagesEndRef} /> {/* Invisible element to scroll to */}
                    </div>

                    {/* Message input area and send button */}
                    <div className="p-4 bg-white border-t border-gray-200 flex items-center rounded-t-lg shadow-inner">
                        <textarea
                            className="flex-1 p-3 border border-gray-300 rounded-lg focus:outline-none focus:ring-2 focus:ring-blue-500 resize-none mr-3"
                            rows="3"
                            placeholder="Type your message... (e.g., 'Create a meeting titled 'Project Alpha', host is 45, on 29/05/2025 at 02:00:00 PM')"
                            value={inputMessage}
                            onChange={handleInputChange}
                            onKeyPress={(e) => {
                                if (e.key === 'Enter' && !e.shiftKey) {
                                    e.preventDefault();
                                    sendMessage();
                                }
                            }}
                            disabled={isLoading}
                        ></textarea>
                        <button
                            onClick={sendMessage}
                            className="bg-blue-600 hover:bg-blue-700 text-white font-bold py-3 px-6 rounded-lg shadow-lg transition duration-300 ease-in-out transform hover:scale-105 disabled:opacity-50 disabled:cursor-not-allowed"
                            disabled={isLoading || !inputMessage.trim() || !geminiApiKey.trim()}
                        >
                            Send
                        </button>
                    </div>
                </div>
            );
        }

        // Render the App component into the 'root' div
        ReactDOM.createRoot(document.getElementById('root')).render(<App />);
    </script>
</body>
</html>
